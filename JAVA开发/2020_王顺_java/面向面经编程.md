面向面经编程

### 如何思考和回答问题

> 是什么?
>
> 底层原理?
>
> 优缺点?
>
> 应用场景?

### 字节跳动

#### 1.Java 中垃圾回收机制中如何判断对象需要回收？常见的 GC 回收算法有哪些？

* ==垃圾回收是通过销毁未使用的对象来回收运行时未使用的内存的过程。==

* 可以使用 c 中的 free ()和 c + + 中的 delete ()等方法执行垃圾收集。在 Java 中，垃圾收集在程序的生命周期中自动进行。这消除了取消内存分配的需要，因此避免了内存泄漏。

* 垃圾收集的主要目标是通过销毁==不被引用的对象==来释放==堆内存==

* 可以通过多种方式释放对对象的引用，使其成为垃圾收集的候选对象:
  * 通过创建一个引用null
  * 给另一个引用赋值
  * 使用匿名对象

![image-20211028093635803](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202110280936916.png)

* java中垃圾收集的三个阶段:

  * Mark objects as alive										--将对象标记为alive

  * Sweep dead objects                                          --清除dead对象

  * Compact remaining objects in memory        --压缩内存中剩余对象、



* 在java中，可作为**GC Root**(当前时刻存活的对象)的对象包括(**两栈两方法**)：
    * ==虚拟机栈中引用的对象==
    
    * 本地方法栈中==JNI==（Native方法）引用的对象
    
    * 方法区中==类静态属性==引用的对象
    
    * 方法区中==常量==引用的对象
    
      



![image-20211028094839244](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202110280948332.png)



>  **解答：**
>
>  * ==只要无法与GC Root建立直接或间接的联系==，就会被判定为可回收对象。
>
>  * 常见的GC回收算法：
>
>    * ==标记清除算法==：算法首先从根集合进行扫描，对存活的对象标记，标记完毕后，再扫描整个空间中未被标记的对象并进行回收
>
>    * ==复制算法==：将可用内存按容量划分为**大小相等的两块**，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。
>
>    * ==标记整理算法==：标记整理算法的标记过程类似标记清除算法，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，类似于磁盘整理的过程，该垃圾回收算法适用于对象存活率高的场景（老年代）
>
>    * ==分代收集算法：==新生代对象存活率低，就采用复制算法；老年代存活率高，就用标记清除算法或者标记整理算法。Java堆内存一般可以分为新生代、老年代和永久代三个模块
>
>      
>
>  ![image-20211028101050099](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202110281010183.png)
>
>  



####  2.HashMap 与 ConcurrentHashMap 的实现原理是怎样的？ConcurrentHashMap 是如何保证线程安全的？

我们都知道HashMap在多线程情况下，在put的时候，插入的元素超过了容量（由负载因子决定）的范围就会触发扩容操作，就是rehash，这个会重新将原数组的内容重新hash到新的扩容数组中，在多线程的环境下，存在同时其他的元素也在进行put操作，如果hash值相同，可能出现同时在同一数组下用链表表示，造成闭环，导致在get时会出现死循环，所以HashMap是线程不安全的。

**HashMap在JDK7和JDK8是有了一些不同的，具体体现如下：**

- JDK7HashMap底层是数组+链表，而JDK8是数组+链表+红黑树
- JDK7扩容采用**头插法**，而JDK8采用尾插法
- JDK7的rehash是**全部rehash**，而JDK8是**部分rehash**。
- JDK8对于key的**hash值计算**相比于JDK7来说有所优化。

**避免hashmap线程安全问题:**

* HashTable
* ConcurrentHashMap                                                   (性能最好)
* Collections.synchronizedMap(hashmap)



针对==HashTable==,==Collections.synchronizedMap==会锁整个hash表的问题，ConcurrentHashMap1.7提出了==分段锁==的解决方案。ConcurrentHashMap1.8使用了==CAS+Synchronized==的解决方案



ConcurrentHashMap含有==线程安全的put== , ==线程安全的Rehash(扩容)==





> 解答:
>
> * HashMap实现原理:
>
>   * jdk1.7:Table数组+Entry链表
>
>   * jdk1.8:Table数组+Entry链表/红黑树(当链表长度大于等于8的时候链表会变成红黑树)
>
>     ![image-20211028102017143](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202110281020227.png)
>
>   
>
> * ConcurrentHashMap 实现原理:
>
>   * jdk1.7 : Segment数组+HashEntry数组
>
>   ![image-20211028102534615](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202110281025681.png)
>
>   ![image-20211028103715974](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202110281037159.png)
>
>   Segment数组(segment本身看做一个hashmap,Segment包含一个HashEntry数组，数组中的每一个HashEntry既是一个键值对，也是一个链表的头节点。)的意义就是将一个大的table分割成多个小的table来进行加锁(==锁分离技术==)，而每一个Segment元素存储的是HashEntry数组+链表，这个和HashMap的数据存储结构一样,可以说，ConcurrentHashMap是一个==二级哈希表==。在一个总的哈希表下面，有若干个子哈希表。
>
>   
>
>   每一个==segment就好比一个自治区==,读写操作高度自治,segment之间互不影响
>
>   
>
>   * jdk1.8 : table数组+链表+红黑树
>
>     ![image-20211028102757834](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202110281027902.png)
>
>     ![image-20211028103907049](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202110281039178.png)
>
>     ConcurrentHashMap的数据结构（数组+链表+红黑树），桶中的结构可能是链表，也可能是红黑树，红黑树是为了提高查找效率。
>
>     * ConcurrentHashMap不接受nullkey和nullvalue
>     * 数据结构：数组＋链表＋红黑树
>     * 并发原理：CAS乐观锁+synchronized锁
>     * 加锁对象：数组每个位置的头节点
>
>     
>
> * concurrentHashMap1.8 如何保证线程安全:
>
>   * 使用volatile保证当Node中的值变化时对于其他线程是可见的
>   * 使用table数组的头结点作为synchronized的锁来保证写操作的安全
>   * 当头结点为null时，使用CAS操作来保证数据能正确的写入。
>
>   
>
>   所谓的==CAS==，即即==compareAndSwap==，执行CAS操作的时候，将内存位置的值与预期原值比较，如果相匹配，那么处理器会自动将该位置值更新为新值，否则，处理器不做任何操作。
>
>   
>
> * ConcurrentHashMap1.7的Size方法是一个嵌套循环，大体逻辑如下：
>
>   1.遍历所有的Segment。
>
>   2.把Segment的元素数量累加起来。
>
>   3.把Segment的修改次数累加起来。
>
>   4.判断所有Segment的总修改次数是否大于上一次的总修改次数。如果大于，说明统计过程中有修改，重新统计，尝试次数+1；如果不是。说明没有修改，统计结束。
>
>   5.如果尝试次数超过阈值，则对每一个Segment加锁，再重新统计。
>
>   6.再次判断所有Segment的总修改次数是否大于上一次的总修改次数。由于已经加锁，次数一定和上次相等。
>
>   7.释放锁，统计结束。
>
>   
>
>   



#### 3.HashMap 和 Hashtable 的区别是什么？

HashMap和Hashtable都实现了Map接口

HashMap的默认初始容量==16==,默认负载因子==0.75==

Hashtable的默认初始容量==11==,默认负载因子==0.75==

主要区别有:

* 线程安全

  >多个线程在执行同一段代码的时候，每次的执行结果和单线程执行的结果都是一样的，不存在执行结果的二义性，就可以称作是线程安全的。

* 线程同步(**synchronized**,**lock**):实现线程安全的一个手段（同步互斥、非阻塞同步、无同步方案[线程本地存储]）

  > 将操作共享数据的代码行作为一个整体，==同一时间只允许一个线程执行指定的程序段，执行过程中其他线程不能参与执行。==目的是为了防止多个线程访问一个数据对象时，对数据造成的破坏。

* 速度



> **解答**:
>
> 1. HashMap==几乎可以等价于Hashtable==，除了==HashMap是非synchronized的，并可以接受null==(HashMap可以接受为null的键值(key)和值(value)，==而Hashtable则不行==)。
> 2. HashMap是非synchronized，而Hashtable是synchronized，这意味着Hashtable是线程安全的，多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。Java 5提供了==ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好==。
> 3. HashMap的迭代器（`Iterator`）是fail-fast迭代器，但是Hashtable的迭代器（`enumerator`）不是fail-fast的。如果有其它线程对HashMap进行的添加/删除元素，将会抛出`ConcurrentModificationException`，但迭代器本身的`remove`方法移除元素则不会抛出异常。这条同样也是Enumeration和Iterator的区别。
> 4. 由于==Hashtable是线程安全的也是synchronized==，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。
> 5. HashMap不能保证随着时间的推移Map中的元素次序是不变的。

fail-fast，它是Java集合的一种==错误检测机制==。当多个线程对集合进行==结构上的改变==的操作时，==有可能==会产生fail-fast机制。



HashMap可以通过下面的语句进行同步：

```java
Map m = Collections.synchronizeMap(hashMap);
```





#### 4.Synchronized 关键字底层是如何实现的？它与 Lock 相比优缺点分别是什么？

我们在开发并发的应用时，经常需要设计这样的对象，该对象的方法会在多线程的环境下被调用，而这些方法的执行都会改变该对象本身的状态。 为了防止竞争条件 (race condition) 的出现，对于这类对象的设计，需要考虑解决以下问题：

- 在任一时间内，只有唯一的公共的成员方法，被唯一的线程所执行。
- 对于对象的调用者来说，如果总是需要在调用方法之前进行拿锁，而在调用方法之后进行放锁，这将会使并发应用编程变得更加困难。
- 如果一个对象的方法执行过程中，由于某些条件不能满足而阻塞，应该允许其它的客户端线程的方法调用可以访问该对象。



在JVM中，==对象在内存中的布局==分为三块区域：对象头、实例数据和填充数据(不一定存在,用于凑齐8的倍数个字节)。如下：

![甘特图](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202111251036552.png)

* ==对象头==(**对象名片**更加生动)：Java头对象，它实现synchronized的锁对象的基础(==所有类都有==),包含了对象的基本信息:

  * 堆对象的布局
  * GC状态
  * 类型
  * 同步状态
  * (identity) hash code
  * *数组长度 (前提你得是数组)*

  > ```java
  > // 打印的在内存中的对象布局的类
  > public class l {
  >     boolean isTrue;// 一个字节作为实例数据
  > }
  > // 主程序
  > public class Main {
  >     public static void main(String[] args) {
  >         l l = new l();
  >         // 打印布局
  >         System.out.println(ClassLayout.parseInstance(l).toPrintable());
  >     }
  > }
  > // xml 
  > <dependency>
  >     <groupId>org.openjdk.jol</groupId>
  >     <artifactId>jol-core</artifactId>
  >     <version>0.16</version>
  > </dependency>
  > ```
  >
  > 
  >
  > ![image-20211030154013523](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202110301540607.png)





* ==实例数据==：存放类的**属性**数据信息(譬如int字段 4byte...)，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐。
* ==填充数据==(**不一定存在!!**)：由于虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。==当对象头和实例数据的总长度 小于8的整数倍字节大小，这时候就会需要填充数据与==



整个==对象头==又包含两个部分 **Mark Word(第一部分),klass pointer(Class Metadata Address)(第二部分) **

* **klass pointer**(64位下,4byte)

  > klass pointer是一个指针，指向了其==类元数据的信息==，jvm使用该指针来确定此对象是类的哪个实例.
  >
  > ![img](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202110281423845.jpeg)
  >
  > 

* **Mark Word**(64位下,8byte)

  > 主要用来**表示对象的线程锁状态**，另外还可以用来配合GC、存放 该对象的hashCode；
  >
  > 锁的状态共有四种:**无锁,偏向锁,轻量锁,重量锁**
  >
  > ![img](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202110281423291.jpeg)
  >
  > 64位下的配置:
  >
  > - unused：未使用的
  > - hashcode：i**dentity** hash code
  > - thread: 偏向锁记录的线程标识
  > - epoch: 验证偏向锁有效性的时间戳
  > - age：分代年龄
  > - biased_lock 偏向锁标志
  > - lock 锁标志
  > - pointer_to_lock_record 轻量锁lock record指针
  > - pointer_to_heavyweight_monitor 重量锁monitor指针
  >
  > 如果你看cms_free这个字体有点奇怪那就对了，开始误画成了unused，后来反应过来**默认开启**“**==指针压缩==**”的情况，那么那一个bit应该是cms_free.
  >
  > * 表格中的“场景”，你也可以理解为“状态”，一个对象在一个时间点是处于一种状态的，但是状态之间**可能会切换**.也就是你使用的对象，就处于当前表格中，其中“一行”的状态.
  >
  > * 为什么==晋升到老年代的年龄设置(XX:MaxTenuringThreshold)不能超过**15**== ？
  >
  >   因为就给了age**==四个bit==**空间，最大就是**1111**(二进制)也就是**15**，多了没地方存.

随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁，==但是锁的升级是单向的==，也就是说只能从低到高升级，不会出现锁的降级。

==重量级锁==也就是通常说synchronized的对象锁，锁标识位为==10==，其中==指针指向的是monitor对象==（也称为管程或监视器锁）的起始地址。

> **解答:**
>
> * ==Synchronized关键字底层是使用monitor对象锁实现的==，每一个对象关联一个monitor对象，而monitor对象可以看成是一个对象锁，它采用互斥的方式让同一时刻至多只有一个线程能持有对象锁，其他线程再想获取这个对 象锁时会被阻塞住，这样就能保证拥有锁的线程可以安全的执行临界区的代码。
>
> * Lock是一个接口，而synchronized是Java中的关键字，是内置的语言实现；Synchronized既可以加在方法上，也可以加在特定的代码块上，而Lock需要显示地指定起始位置和终止位置。
>
>   **优点:**
>
>   * Synchronized==不====需要用户手动==去释放锁,系统会自动让线程释放锁的占用,无论中途是否==遇到异常都能自动释放==；
>   * 而Lock==需要用户====手动==去释放，一般写在finally块中避免执行中途==遇到异常无法正常释放锁==
>
>   **缺点:**
>
>   * Lock可以被中断或设置超时等待，可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待锁的线程会一直等下去，不能响应中断。
>   * Lock可以设置公平锁，而synchronized只能是非公平实现(公平锁通过在锁竞争前判断自己是否是头节点来实现)。
>   * Lock可以支持多个条件变量(Condition)，而synchronized只支持一个条件变量，所有的等待都在同一个waitset中。





#### 5.HashMap 实现原理，为什么使用红黑树？

* **RQ1:HashMap数据结构**

  * JDK1.7使用的是==数组==+==单链表==

  * JDK1.8使用的是==数组==+==链表\红黑树==

    > 若桶中链表元素大于等于==8==时(并且数组大小为64),==链结构会自动转换为红黑树==;
    >
    > > 这里的大于等于8 可以这样理解:在put操作中会先遍历一遍链表到末尾,并会统计元素个数,如果插入待插入元素前,链表中的元素=8时(并且数组大小64)自动转换为红黑树
    >
    > 若桶中  树  元素小于等于==6==时，==树结构还原成链表形式==
    >
    > * 红黑树平均查找时间为(log(n)),长度为8，查找长度为log(8)=3，链表的平均查找长度为n/2，当长度为8时，平均查找长度为8/2=4，==这才有转换成树的必要==
    > * 链表长度如果是小于等于6，6/2=3，虽然速度也很快的，但是转化为树结构和生成树的开销会很大。
    > * 选择6和8的原因是，中间有个差值**==7==**可以==防止链表和树之间频繁的转换==。



* **RQ2:如何解决hash冲突:**

  ==通过异或运算计算出来的hash比较均匀==,异或运算能更好的保留各部分的特征，如果采用&运算计算出来的值会向0靠拢，采用|运算计算出来的值会向1靠拢

  * 开发定址法
  * 再哈希法
  * **链地址法**（HashMap中处理Hash冲突使用的方法）
  * 建立公共溢出区



* **RQ3:为什么HashMap中table数组用transient修饰?**

  transient 表示易变的意思，在 Java 中，被该关键字修饰的变量==不会被默认的序列化机制序列化==。

  

  HashMap 并没有使用默认的序列化机制，而是通过实现readObject/writeObject两个方法自定义了序列化的内容。

  

  序列化 talbe 存在着两个问题:

  * table ==多数情况下是无法被存满的==，序列化未使用的部分，浪费空间。
  * 同一个键==值对在不同 JVM 下，所处的桶位置可能是不同的==，在不同的 JVM 下反序列化 table 可能会发生错误。

  HashMap 的get/put/remove等方法第一步就是根据 hash 找到键所在的桶位置，但如果键没有覆写 hashCode 方法，计算 hash 时最终调用 Object 中的 hashCode 方法。但 Object 中的 hashCode 方法是 native 型的，不同的 JVM 下，可能会有不同的实现，产生的 hash 可能也是不一样的。也就是说同一个键在不同平台下可能会产生不同的 hash，此时再对在同一个 table 继续操作，就会出现问题。

  

* **RQ4:为什么JDK1.8中不完全使用红黑树?**

  * ==put和remove过程中，红黑树要通过左旋，右旋、变色这些操作来保持平衡，另外构造红黑树要比构造链表复杂====开销较大==，在链表的节点不多的时候，从整体的性能看来， 数组+链表+红黑树的结构可能不一定比数组+链表的结构性能高
  * HashMap==频繁的扩容==，会造成底部==红黑树不断的进行拆分和重组==，这是非常耗时的

  > * 平衡二叉树:
  >
  >   又被称为AVL树（有别于AVL算法），且具有以下性质：
  >
  >   * 它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，
  >   * 左右两个子树都是一棵平衡二叉树。
  >
  >   特点:
  >
  >   * 具有==二叉查找树==的全部特性。
  >   * 每个节点的左子树和右子树的==高度差至多等于1==
  >
  >   
  >
  > * 红黑树:
  >
  >   AVL树虽然解决了二叉查找树退化为近似链表的缺点,不过不是最佳方案.每次插入\删除节点都会破坏第二个条件,进而我们都需要通过左旋和右旋来进行调整,开销大.显然==对于频繁进行插入删除的场景,性能大打折扣!---因此有了红黑树==
  >
  >   性质:
  >
  >   * 性质1：每个节点要么是**黑色**，要么是**红色**。
  >   * 性质2：根节点是**黑色**。
  >   * 性质3：每个叶子节点（**NIL**）是**黑色**。
  >   * 性质4：每个**红色**节点的两个子节点一定都是**黑色**。不能有两个红**色节**点相连。
  >   * 性质5：任意一节点到每个叶子节点的路径都包含**数量相同**的**黑结点**。俗称：**黑高**！
  >
  >   ![image-20211029100412935](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202110291004071.png)
  >
  >   由于性质5的存在,我们叫红黑树这种平衡为**==黑色完美平衡==**。
  >
  > **红黑树能自平衡，它靠的是什么？三种操作：左旋、右旋和变色**
  >
  > * 左旋：以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。
  > * 右旋：以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变
  > * 变色：结点的颜色由红变黑或由黑变红。



* **RQ5:put()方法 和 get()方法**

  > put() 返回的是与==key关联的先前值==，如果没有key 的映射，则为null 
  >
  > * 调用 hash(key.hashCode()) 方法计算 key 的 hash 值（其中JDK1.7用了9次扰动处理=4次位运算+5次异或；JDK1.8只用了2次扰动处理=1次位运算+1次异或）[**扰动是为了让数据更加的均匀**]，然后和（数组长度-1）做异或运算，得出数组下标；
  > * 当table中的元素个数大于阈值（capacity * loadfactor）时，容器会进行扩容resize操作，将table数组大小扩充为2倍；
  > * * 如果key的hash值对应的table下标元素为空，说明还没有元素，则直接插入，若不为空，则说明存在元素，发生了hash冲突，接下来要遍历链表或红黑树进行匹配查找；
  >   * 如果遍历的过程中，==或equals返回true，说明找到了对应的对象，直接更新该对象的value，返回旧value；
  >   *  如果遍历结束，==或equals还是返回false，说明没有找到了对应的对象，则需要在该链表或红黑树中插入（JDK1.7使用头插法，JDK1.8 使用尾插法）；

  > get()
  >
  > * 通过调用hash(key.hashCode()) 方法，然后和（数组长度-1）做异或运算，得出数组下标；
  > * 顺序遍历链表或红黑树，==或equals返回true，则返回对应的value值，否则返回null。

  

> 解答:
>
> * 略
> * java8不是用红黑树来管理hashmap，而是在hash值相同的情况下（且重复数量大于8），用==红黑树来管理数据==。 红黑树相当于排序数据，可以自动的使用二分法进行定位，性能较高。一般情况下，==hash值做的比较好的话基本上用不到红黑树。==





#### 6.简述 Java 的反射机制及其应用场景

```java
import java.lang.reflect.*;
```

反射（Reflection） 是 Java 程序开发语言的特征之一，它==允许运行中的 Java 程序对自身进行检查==，或者说“自审”，==并能直接操作程序的内部属性和方法==。



反射是所有注解实现的原理



常见面试考察点:

* 如何反射获取 Class 对象
* 如何反射获取类中的所有字段
* 如何反射获取类中的所有构造方法
* 如何反射获取类中的所有非构造方法



> 通俗地讲，一提到反射，我们就可以想到==镜子==。镜子可以明明白白地照出我是谁，还可以照出别人是谁。反映到程序中，反射就是用来==让开发者知道这个类中有什么==，以及别的类中有什么。

![image-20211029110508736](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202110291105830.png)

**获取class的三种方法:**

```java
// 1.通过字符串获取Class对象，这个字符串必须带上完整路径名
Class studentClass = Class.forName("com.test.reflection.Student");
// 2.通过类的class属性
Class studentClass2 = Student.class;
// 3.通过对象的getClass()函数
Student studentObject = new Student();
Class studentClass3 = studentObject.getClass();
```

```java
getXXXX() 			//获取共有的xxx
getDeclaredXXXX() 	//获取所有的xxx
```



> 解答:
>
> * 略
>
> * 应用场景:
>
>   * 模块化开发
>   * 注解开发
>   * 动态代理设计模式
>   * 框架开发(Spring......)
>
>   
>
>   Spring 通过 XML 配置模式装载 Bean 的过程：
>
>   1. 将程序内所有 XML 或 Properties 配置文件加载入内存中
>   2. Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息
>   3. 使用反射机制，根据这个字符串获得某个类的Class实例
>   4. 动态配置实例的属性





#### 7.简述 Synchronized，volatile，可重入锁(ReentrantLock)的不同使用场景及优缺点

**Synchronized:**

* 修饰符==仅适用于方法和块==，而不适用于变量和类
* 当多个线程试图同时操作同一个 java 对象时。如果一个方法或块声明为 synchronized，那么==一次只允许一个线程==对给定的对象执行该方法或块，以便解决数据不一致的问题
* 这个关键字的主要缺点是它==增加了线程的等待时间==，并==造成性能问题==
* 当线程在给定对象上执行同步方法时，其余线程不允许在同一对象上同时执行任何同步方法。但是允许其余的线程同时执行非同步方法。

> 用于静态方法时锁住的是xxx.class



**volatile**：

[联系JMM理解](#volatile)

* 只适用于==变量的修饰符==
* 如果一个变量被声明为 volatile，那么 ==JVM 将创建一个单独的本地副本==。线程执行的每个修改都将在本地副本中执行，这样就==不会对其余线程产生影响==。克服数据不一致性问题是优点，而 volatile 关键字为每个线程创建和维护一个单独的副本增==加了编程的复杂性并造成性能问题==是缺点。



**Atomic Modifier:  **

当这些类的对象分别表示 int、 long、 boolean 和 object 引用的原子变量时，可以解决数据不一致问题。



**可重入锁**(Synchronized也是可重入锁)

通过==为每个锁====关联一个请求计数器和一个获得该锁的线程==。当计数器为0时，认为锁是未被占用的。线程请求一个未被占用的锁时，JVM将记录该线程并将请求计数器设置为1，此 时该线程就获得了锁，==当该线程再次请求这个锁，计数器将递增==，当线程退出同步方法或者同步代码块时，计数器将递减，==当计数器为0时，线程就释放了该对象，其他线程才能获取该锁==

<span id="answer7"></span>

| Synchronized                                                 |                         volatile                         |                     Atomic Modifier                      |
| :----------------------------------------------------------- | :------------------------------------------------------: | :------------------------------------------------------: |
| 只适用于修饰块或方法,[静态方法时使用 锁住的是xxx.class)]     |                     只适用于修饰变量                     |                     只适用于修饰变量                     |
| 使用同步修改器实现了一个基于锁的并发算法，但受到锁的限制     |  Volatile 提供了实现一个更具可伸缩性的非阻塞算法的能力   |           原子算法还提供了实现非阻塞算法的能力           |
| 由于锁的获取和释放，与volatile和Atomic 关键字相比，性能相对较低 |         与 synchronized 关键字相比，性能相对较高         |   与 volatile 和 synchronized 关键字相比，性能相对较高   |
| 由于它的锁定性质，它不能免于并发性的危险，如==死锁和活锁==   | 由于它的非锁定性质，它不会受到死锁和活锁等并发危害的影响 | 由于它的非锁定性质，它不会受到死锁和活锁等并发危害的影响 |
|                                                              |                                                          |                                                          |
| https://blog.csdn.net/zcyt085/article/details/108435529      |                  附加功能：禁止指令重排                  |                                                          |



![image-20211108091813243](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202111080918375.png)



> https://developer.aliyun.com/article/762986
>
> Singleton singleton = new Singleton();
>
> 这行代码到底做了什么事情，大致过程如下：
>
> - a、JVM为对象分配一块内存M
> - b、在内存M上为对象进行初始化
> - c、将内存M的地址复制给singleton变量
>
> 指令b,c可能会被JVM重排,volatile 可以禁止指令重排



Synchronized死锁问题

死锁产生的条件:

* 互斥条件：指进程对所分配到的资源进行排它性使用，==即在一段时间内某资源只由一个进程占用==。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。
* 请求和保持条件：指==进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有==，此时请求进程阻塞，==但又对自己已获得的其它资源保持不放==。
* 不剥夺条件：==指进程已获得的资源，在未使用完之前，不能被剥夺==，只能在使用完时由自己释放。
* 环路等待条件：指在发生死锁时，必然存在一个进程——==资源的环形链==，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。

```java

public class SynchronizedDeadLock {
    public static void main(String[] args) {
        //定义2个锁对象
        final Object o1 = new Object();
        final Object o2 = new Object();
        Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (o1) {//获取o1的锁
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    synchronized (o2) {//获取o2的锁

                    }
                }
            }
        });
        Thread t2 = new Thread(new Runnable() {

            @Override
            public void run() {
                synchronized (o2) {//获取o2的锁
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    synchronized (o1) {//获取o1的锁

                    }
                }
            }
        });
        //启动
        t1.start();
        t2.start();
    }
}
```

> 解答:
>
> [详情见表格](#answer7)



#### 8.[?]简述 BIO, NIO, AIO 的区别

- BIO 就是传统的 [java.io](https://link.zhihu.com/?target=http%3A//java.io/) 包，它是基于流模型实现的，==交互的方式是**同步、阻塞**方式==，也就是说在读入输入流或者输出流时，在读写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。它的优点就是==代码比较简单====、直观==；缺点就是 ==IO 的效率和扩展性很低，容易成为应用性能瓶颈==。
- NIO 是 Java 1.4 引入的 java.nio 包，提供了 Channel、Selector、Buffer 等新的抽象，==可以构建多路复用的、**同步非阻塞** IO 程序==，同时提供了更接近操作系统底层==高性能的数据操作方式==。
- AIO 是 Java 1.7 之后引入的包，是 NIO 的升级版本，==提供了**异步非堵塞的 IO** 操作方式==，所以人们叫它 AIO（Asynchronous IO），异步 IO 是**基于事件和回调机制**实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。



**五种IO模型**

1. 阻塞I/O（blocking I/O）

2. 非阻塞I/O （nonblocking I/O）

3. I/O复用(select 和poll) （I/O multiplexing）

4. 信号驱动I/O （signal driven I/O (SIGIO)）

5. 异步I/O （asynchronous I/O (the POSIX aio_functions)）

前面四种都是同步io、第五种是异步IO；



==**阻塞（**Blocking IO**）**==

阻塞I/O 在调用一个io函数的时候，如果没有获取到数据的情况下，那么就会一直等待；等待的过程中会导致整个应用程序一直是一个阻塞的过程，无法去做其他的实现。

![image-20211031181301732](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202110311813801.png)

**应用程序**想要读取数据就会调用`recvfrom`,而`recvfrom`会通知OS来执行，OS就会判断**数据报是否准备好**(比如判断是否收到了一个完整的UDP报文，如果收到UDP报文不完整，那么就继续等待)。当数据包准备好了之后，OS就会**将数据从内核空间拷贝到用户空间**(因为我们的用户程序只能获取用户空间的内存，无法直接获取内核空间的内存)。拷贝完成之后`socket.read()`就会解除阻塞，并得到read的结果。

阻塞两个地方：1. OS等待数据报准备好。2.将数据从内核空间拷贝到用户空间。



==**非阻塞（Non-Blocking IO）**==

非阻塞I/O 不管是否有获取到数据，都会立马获取结果，如果没有获取数据的话、那么就不间断的循环重试，但是我们整个应用程序不会实现阻塞。

![img](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202110311814961.jpeg)



==**I/O复用（IO Multiplex）**==

**IO实际指的就是网络的IO、多路也就是多个不同的tcp连接**；**复用也就是指使用同一个线程合并处理多个不同的IO操作，这样的话可以减少CPU资源**。（单个线程可以同时处理多个不同的io操作，应用场景非常广泛：redis原理。Mysql连接原理）

![img](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202110311815700.jpeg)



**==信号驱动I/O(Signal driven IO)==**

![img](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202110311816750.jpeg)

发出一个请求实现观察监听，当有数据的时候直接走我们异步回调；





**==异步I/O(Asynchronous IO)==**

![img](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202110311816358.jpeg)

Asynchronous IO调用中是真正的无阻塞，其他IO model中多少会有点阻塞。程序发起read操作之后，立刻就可以开始去做其它的事。而在内核角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。



==**NIO与BIO区别**==

|           IO            |             NIO             |
| :---------------------: | :-------------------------: |
| 面向流(stream oriented) | 面向缓冲区(Buffer oriented) |
|   阻塞式(Blocking IO)   |  非阻塞式(Non blocking IO)  |
|                         |     选择器(多路复用器)      |



#### 9.Java 类的加载流程是怎样的？什么是双亲委派机制？

```java
// 查看class文件里面的东西
//javap是 Java class文件分解器，可以反编译（即对javac编译的文件进行反编译），也可以查看java编译器生成的字节码。用于分解class文件。
//javac命令是将源代码编程成class字节码文件
//  -v  -verbose             输出附加信息
javap -v ClassA.class
```



![123](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202111011120286.png)



Java类的加载过程==主要分为三个步骤==:

* 加载
* 链接
* 初始化



**加载阶段**

> 将字节码(maybe二进制字节流)数据从不同的数据源(jar文件、class文件、网络数据源)读取到JVM中,并映射为Class对象；
>
> 如果输入数据不是ClassFile的结构,则会抛出ClassFormatError

==加载阶段是用户参与的阶段，我们可以自定义类加载器，去实现自己的类加载过程。==



**链接阶段**

> 这是核心的步骤，简单说是把原始的类定义信息平滑地转入 JVM 运行的过程中。
>
> * 验证（Verification），==这是虚拟机安全的重要保障，JVM 需要核验字节信息是符合 Java 虚拟机规范的==，否则就被认为是 VerifyError，这样就防止了恶意信息或者不合规的信息危害 JVM 的运行，验证阶段有可能触发更多 class 的加载。
> * 准备（Preparation），==创建类或接口中的静态变量，并初始化静态变量的初始值。==但这里的“初始化”和下面的显式初始化阶段是有区别的，侧重点在于分配所需要的内存空间，不会去执行更进一步的 JVM 指令。
> * 解析（Resolution），在这一步会将常量池中的==符号引用（symbolic reference）替换为直接引用==(在内存中真实存在的引用)。在Java 虚拟机规范中，详细介绍了类、接口、方法和字段等各个方面的解析。



**初始化阶段**

> 这一步真正去执行类初始化的代码逻辑，包括静态字段赋值的动作，以及执行类定义中的静态初始化块内的逻辑，编译器在编译阶段就会把这部分逻辑整理好，==父类型的初始化逻辑优先于当前类型的逻辑==。



**==双亲委派==**

简单说就是当类加载器（Class-Loader）试图加载某个类型的时候，除非父加载器找不到相应类型，否则尽量将这个任务代理给当前加载器的父加载器去做。

目的:==使用委派模型的目的是避免重复加载 Java 类型。==

![img](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202111011418634.png)





#### 10.JMM 中内存模型（java内存模型）是怎样的？什么是指令序列重排序？

[超级好的解释！必看](https://zhuanlan.zhihu.com/p/29881777)

我们常说的==JVM内存模式指的是JVM的内存分区，是一种物理划分==；而==Java内存模式是一种虚拟机规范==。

Java程序中天然的有序性可以总结为一句话：==如果在本地线程内观察，所有操作都是有序的==（“线程内表现为串行”(Within-Thread As-If-Serial Semantics)）；==如果在一个线程中观察另一个线程，所有操作都是无序的==（“指令重排序”现象和“线程工作内存与主内存同步延迟”现象）



 **什么是JMM模型**

> * ==JMM是一种抽象的概念，并不真实存在，是一组规范或者规则==；关注的是多个线程对共享内存空间和线程私有工作空间的访问方式，围绕并发的原子性、有序性、可见性来展开的
> * JMM通过定义了对==变量（包括实例成员、静态成员和组成数组对象的元素）的访问方式==，在程序运行时，运行程序的是实体是线程，每个线程创建时候，虚拟机都会为每个线程分配一定的内存空间，每个线程的内存空间用来存储线程私有的数据。但是JMM中规定数据都是存储在共享的主内存空间，而且每个线程不能直接操作主内存的空间，只能访问主内存的空间，且每个线程可以操作自己的工作空间，所以每个线程将自己用到的数据从共享的主内存空间中拷贝一份到其工作空间，操作完之后回写到主内存空间。
> * 线程中的工作空间是私有的，线程之间不能访问对方的工作空间。比如线程A和线程B，A不能访问B的工作空间，同时，B也不能访问A的工作空间。



 **JVM运行时数据区 和JMM区别 和联系**

>  区别：
>
> *  JMM是一种抽象的概念，并不真实存在，是一组规范或者规则，通过规则来控制变量的访问。围绕多并发展开
>
> * 运行时数据区域： 在JVM在运行程序时，内存的划分是具体的，是JVM运行时必要的内存划分
>
> 
>
> 联系：
>
> * JMM中内存有==共享的内存空间==和线程==私有的工作空间==，JVM运行时数据区有  方法区、堆、本地方法栈、虚拟机栈、程序计数器
>
> * JVM运行时数据区共享的内存空间有   方法区和堆，所以可以理解  JMM的共享内存区域包含了 方法区和栈。JMM的线程私有空间包含了  程序计数器、本地方法栈、虚拟机栈



 **Java内存模型与硬件内存架构的关系**

> 因为JMM只是一种抽象的概念，是一组规则，并不实际存在，不管是工作内存的数据还是主内存的数据，对于计算机硬件来说都会存储在计算机主==内存==、==CPU缓存==和==CPU寄存器==中，所以Java内存模型和计算机硬件内存架构是一个相互交叉的关系，是一种抽象概念划分与真实物理硬件的交叉。
>
> ![img](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202111021104172.png)



 **JAVA内存模型数据同步8大原子操作**

> 1、数据同步8大原子操作：
>
> * lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。
> * unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
> * read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用
> * load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
> * use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。
> * assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
> * store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。
> * write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。
>
> ==不允许read和load、store和write操作之一单独出现==

**eg:**

```java
// 共享变量
public static volatile boolean initFlag = false;
public static void main(String[] args) throws InterruptedException {
    // 开启线程1
    new Thread(()->{
        System.out.println("start fetching...");
        while (!initFlag) {}
        System.out.println("success");
    }).start();
    
    Thread.sleep(3000);
    //另一个线程2
    new Thread(()->{
        //该方法修改initFlag值为true
        prepareData();
    }).start();
}
```

<img src="https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202111021435781.png" alt="image-20211102143528622" style="zoom:150%;" />



总线:公共信息的传送线路

> 存在一种问题:
>
> * store操作经过总线,有可能立即使得其他线程监听到且没有执行write操作,其他线程执行read操作 读取的还是旧值.
>
> volatile的解决方法:
>
> * store之前将内存行lock,wirte完成后unlock 
>
> ![image-20211102145642055](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202111021456149.png)

**Volatile**<span id="volatile"></span>

> Java中的volatile关键字：volatile关键字可以保证直接从主存中读取一个变量，如果这个变量被修改后，总是会被写回到主存中去。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是volatile变量都是如此，普通变量与volatile变量的区别是：
>
> * 使用 volatile 修饰共享变量后，每个线程要操作变量时会从主内存中将变量拷贝到本地内存作为副本，当线程操作变量副本并写回主内存后，会通过 ==**CPU 总线嗅探机制**==告知其他线程该变量副本已经失效，需要==重新从主内存中读取==。
>
> **嗅探机制工作原理**：每个处理器通过监听在总线上传播的数据来检查自己的缓存值是不是过期了，如果处理器发现自己缓存行对应的内存地址修改，就会将当前处理器的缓存行设置无效状态，当处理器对这个数据进行修改操作的时候，会重新从主内存中把数据读到处理器缓存中。
>
> > 注意：基于 CPU 缓存一致性协议，JVM 实现了 volatile 的可见性，但由于==总线嗅探机制，会不断的监听总线，如果大量使用 volatile 会引起总线风暴==。所以，volatile 的使用要适合具体场景。



**内存屏障禁止特定类型的处理器重排序**

通过内存屏障指令来禁止特定类型的处理器重排序。通过==禁止特定类型的编译器重排序和处理器重排序==，为程序员==提供一致的内存可见性保证==。为了保证内存可见性，Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。



#### 11.Java 线程间有多少通信方式？

- waite 和 notify \ notifyAll
- Lock 和 Condition
- 使用管道流进行线程通信
- 使用阻塞队列控制线程通



> 当我们使用线程来同时运行多个任务时，可以通过使用锁(互斥)来同步两个任务的行为，从而使得一个任务不会干扰到另外一个任务，这解决的是==线程间彼此干涉==的问题，现在我们需要来解决==线程间彼此协调==的问题，也就是线程间通信问题。



1. **waite 和 notify \ notifyAll**

可以借助于Object类提供的wait()、notify()、notifyAll()三个方法，这三个方法属于Object类。但这三个方法必须由同步监视器对象来调用，这可分为两种情况
①对于用synchronized修饰的同步方法，因为该类的默认实例(this)就是同步监视器，所以可以在同步方法中直接调用这三个方法。
②对于用synchronized修饰的同步代码块，同步监视器是synchronized后括号里的对象，所以必须使用该对象调用这三个方法。

需要注意的是notify()方法只能随机唤醒一个线程，如果要唤醒所有线程，请使用notifyAll()。



2. **Lock 和 Condition**

如果程序不用synchronized关键字来进行同步，而是用Lock对象来保证同步，则系统中==不存在隐式的同步监视器==，也就不能使用wait()、notify()、notifyAll()方法进行线程通信了。
使用Lock对象的方式，Java提供了一个Condition类来保持协调，使用Condition可以让那些已经得到Lock对象却无法继续执行的线程释放Lock对象，Condition对象也可以唤醒其他处于等待的线程。
Condition将同步监视器方法wait()、notify()、notifyAll()分解成截然不同的对象，以便通过将这些对象与Lock对象组合使用，为每个对象提供多个等待集(wait-set)。在这种情况下，Lock替代了同步方法和同步代码块，Condition替代了同步监视器的功能。
Condition实例被绑定在一个Lock对象上。要获得特定Lock实例的Condition实例，调用Lock对象的newCondition()方法获得即可。Condition类提供了以下三个方法：

* await():
* signal():
* signalAll():



3. **使用管道流进行线程通信**

通过输入/输出在线程间进行通信通常很有用。Java中对应的实现就是PipedWriter类和PipedReader类。这种使用管道来通信的模型可以看成是"生产者-消费者"问题的变种，这里的管道就是一个封装好的解决方案。管道基本上就是一个阻塞队列，它存在于引入阻塞队列之前的java版本中。在实际开发中，很少会使用到管道流。



4. **使用阻塞队列控制线程通**

Java5提供了一个BlockingQueue接口，虽然BlockingQueue也是Queue的子接口，但它的主要用途不是作为容器，而是作为线程同步的工具。
BlockingQueue具有一个特征：当生产者线程试图向BlockingQueue中放入元素时，如果该队列已满则线程被阻塞。而消费者线程 在取元素时，如果该队列已空则该线程被阻塞。
程序的两个线程通过交替向BlockingQueue中放入元素、取出元素，即可很好地控制线程的通信。



#### 12.Java 中接口和抽象类的区别

* 抽象类

  在 Java 中，被关键字 ==abstract== 修饰的类称为抽象类；被 abstract 修饰的方法称为抽象方法，抽象方法只有方法声明没有方法体。

  抽象类有以下几个特点：

  > 1. 抽象类不能被实例化，只能被继承。
  > 2. 包含抽象方法的类一定是抽象类，但抽象类不一定包含抽象方法（抽象类可以包含普通方法）。
  > 3. 抽象方法的权限修饰符只能为 public、protected 或 default，默认情况下为 ==public==。
  > 4. 一个类继承于一个抽象类，==则子类必须实现抽象类的抽象方法==，==如果子类没有实现父类的抽象方法，那子类必须定义为抽象类。==
  > 5. 抽象类可以包含属性、方法、构造方法，但构造方法不能用来实例化对象，只能被子类调用。



* 接口

  接口可以看成是一种特殊的类，只能用 interface 关键字修饰。

  Java 中的接口具有以下几个特点：

  > 1. 接口中可以包含变量和方法，变量被隐式指定为 public static final，方法被隐式指定为 public abstract（JDK 1.8 之前）。
  > 2. 接口支持多继承，==即一个接口可以继承（extends）多个接口==（普通的类不能多继承），间接解决了 Java 中类不能多继承的问题。
  > 3. 一个类可以同时实现多个接口，一个类实现某个接口则必须实现该接口中的抽象方法，否则该类必须被定义为抽象类。

  

* 相同点

  接口和抽象类很像，它们都具有如下特征。

  - 接口和抽象类==都不能被实例化==，主要用于被其他类实现和继承。
  - 接口和抽象类==都可以包含抽象方法==，实现接口或继承抽象类的普通子类都必须实现这些抽象方法。



* 区别

  |        参数        |                            抽象类                            |                             接口                             |
  | :----------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
  |        实现        | 子类使用 extends 关键字来继承抽象类，如果子类不是抽象类，则需要提供抽象类中所有声明的方法的实现。 | 子类使用 implements 关键字来实现接口，需要提供接口中所有声明的方法的实现。 |
  |     访问修饰符     |           可以用 public、protected 和 default 修饰           |           默认修饰符是 public，不能使用其它修饰符            |
  |        方法        |                     完全可以包含普通方法                     | 只能包含抽象方法、静态方法、默认方法和私有方法，不能为普通方法提供方法实现 |
  |        变量        |          既可以定义普通成员变量，也可以定义静态常量          |            只能定义静态常量，不能定义普通成员变量            |
  |      构造方法      | 抽象类里的构造方法并不是用于创建对象，而是让其子类调用这些构造方法来完成属于抽象类的初始化操作 |                         没有构造方法                         |
  |      初始化块      |                       可以包含初始化块                       |                       不能包含初始化块                       |
  |     main 方法      |                 可以有 main 方法，并且能运行                 |                        没有 main 方法                        |
  | 与普通Java类的区别 |     抽象类不能实例化，除此之外和普通 Java 类没有任何区别     |                       是完全不同的类型                       |
  |      运行速度      |                      比接口运行速度要快                      |    需要时间去寻找在类种实现的方法，所以运行速度稍微有点慢    |

注意：java9中的接口可以包含！！！

- **常量**
- **抽象方法**
- **默认方法**
- **静态方法**
- **私有方法**
- **私有静态方法**



#### 13.简述 ArrayList 与 LinkedList 的底层实现以及常见操作的时间复杂度

**ArrayList**

* ArrayList 通过==数组==实现，一旦我们实例化 ArrayList 无参数构造函数默认为数组初始化长度为 10
* add 方法底层实现如果增加的元素个数超过了 10 个，那么 ArrayList 底层会新生成一个数组，长度为原数组的 1.5 倍+1，然后==将原数组的内容复制到新数组当中==，扩容数组调用的方法 Arrays.copyOf(objArr, objArr.length + 1);



**LinkedList**

* LinkedList 底层的数据结构是基于==双向循环链表的,且头结点中不存放数据==,
* 节点实例保存业务数据，前一个节点的位置信息和后一个节点位置信息

<img src="https://img-blog.csdnimg.cn/20200429135655426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d1NzU2MjcxOTA5,size_16,color_FFFFFF,t_70" alt="img" style="zoom:150%;" />



**区别:**

1.ArrayList是实现了基于动态数组结构,LinkedList是基于链表数据结构.
2.对于随机访问get和set,ArrayList优于Linkedlist,因为ArrayList可以随机定位,而linkedList要移动指针一步一步的移动到节点处.
3.对于新增和删除操作,linkedlist比较占优势,只需要对指针进行修改即可,而ArrayList要移动数据来填补被删除的对象的空间



**使用场景**:

（1）如果应用程序对各个索引位置的元素进行大量的存取操作，ArrayList对象要远优于LinkedList对象；
（2）如果应用程序主要是对列表元素进行循环，并且循环时候进行插入或者删除操作，LinkedList对象要远优于ArrayList对象



> ArrayList 
> get() 直接读取第几个下标，复杂度 ==O(1)==
> add(E) 添加元素，直接在后面添加，复杂度==O（1）==
> add(index, E) 添加元素，在第几个元素后面插入，后面的元素需要向后移动，复杂度==O（n）==
> remove（）删除元素，后面的元素需要逐个移动，复杂度==O（n）==
>
> LinkedList 
> get() 获取第几个元素，依次遍历，复杂度==O(n)==
> add(E) 添加到末尾，复杂度==O(1)==
> add(index, E) 添加第几个元素后，需要先查找到第几个元素，直接指针指向操作，复杂度==O(n)==
> remove（）删除元素，直接指针指向操作，复杂度==O(1)==



#### 14.Java 常见锁有哪些？ReetrantLock 是怎么实现的？

* 公平锁 / 非公平锁
* 可重入锁 / 不可重入锁
* 独享锁 / 共享锁
* 互斥锁 / 读写锁
* 乐观锁 / 悲观锁
* 分段锁
* 偏向锁 / 轻量级锁 / 重量级锁
* 自旋锁



**公平锁**

> 公平锁是指多个==线程按照申请锁的顺序来获取锁==。



**非公平锁**

> * 非公平锁是指==多个线程获取锁的顺序并不是按照申请锁的顺序==，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。
> * 对于Java ReentrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。==非公平锁的优点在于吞吐量比公平锁大==。
> * 对于Synchronized而言，也是一种非公平锁。由于其并不像ReentrantLock是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁。



**可重入锁**

> 广义上的可重入锁指的是==可重复可递归调用的锁==，在**外层使用锁之后，在内层仍然可以使用**，并且不发生死锁（前提得是同一个对象或者class），这样的锁就叫做可重入锁。==ReentrantLock==和==synchronized==都是可重入锁



**不可重入锁**

> 不可重入锁，与可重入锁相反，不可递归调用，递归调用就发生死锁



**独享锁**

> 该锁每一次只能被一个线程所持有。



**共享锁**

> 该锁可被多个线程共有，典型的就是ReentrantReadWriteLock里的读锁，它的读锁是可以被共享的，但是它的写锁确每次只能被独占。
>
> 另外读锁的共享可保证并发读是非常高效的，但是读写和写写，写读都是互斥的。
>
> 独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享
>
> 对于Synchronized而言，当然是独享锁。



**互斥锁**

> 在访问共享资源之前对进行加锁操作，在访问完成之后进行解锁操作。 加锁后，任何其他试图再次加锁的线程会被阻塞，直到当前进程解锁。
>
> 如果解锁时有一个以上的线程阻塞，那么所有该锁上的线程都被编程就绪状态， 第一个变为就绪状态的线程又执行加锁操作，那么其他的线程又会进入等待。 在这种方式下，只有一个线程能够访问被互斥锁保护的资源



**读写锁**

> 读写锁既是互斥锁，又是共享锁，read模式是共享，write是互斥(排它锁)的。
>
> **读写锁有三种状态：**读加锁状态、写加锁状态和不加锁状态
>
> 读写锁在Java中的具体实现就是ReadWriteLock
>
> 一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占有读模式的读写锁。



**悲观锁**

> 总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。



**乐观锁**

> 总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。



 **分段锁**

> 分段锁其实是一种锁的设计，并不是具体的一种锁
>
> 并发容器类的加锁机制是基于粒度更小的分段锁，分段锁也是提升多并发程序性能的重要手段之一。



**锁的状态：**

- 1.无锁状态
- 2.偏向锁状态
- 3.轻量级锁状态
- 4.重量级锁状态

锁的状态是通过对象监视器在对象头中的字段来表明的。

四种状态会随着竞争的情况逐渐升级，而且是不可逆的过程，即不可降级。

这四种状态都不是Java语言中的锁，而是Jvm为了提高锁的获取与释放效率而做的优化(使用synchronized时)。

**偏向锁**

> 偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。

**轻量级**

> 轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。

**重量级锁**

> 重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。



**自旋锁**

>自旋锁（spinlock）：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。它是为实现保护共享资源而提出一种锁机制。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，”自旋”一词就是因此而得名。





**==ReentrantLock底层使用了CAS+AQS队列实现==**

#####  **CAS**（Compare and Swap）

CAS是一种无锁算法。有3个操作数：内存值V、旧的预期值A、要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。

```java
do{
  备份旧数据；
  基于旧数据构造新数据；
}while(!CAS( 内存地址，备份的旧数据，新数据 ))
```

该操作是一个原子操作，被广泛的应用在Java的底层实现中。

在Java中，CAS主要是由sun.misc.Unsafe这个类通过JNI调用CPU底层指令实现。



#####  CAS的开销

CAS速度非常快：

1. ==CAS是CPU指令级的操作，只有一步原子操作；==
2. CAS避免了请求操作系统来裁定锁的问题，==不用麻烦操作系统，直接在CPU内部就搞定了==

CAS仍然可能有消耗：可能出现cache miss的情况，会有更大的cpu时间消耗。



##### AQS队列

AQS是一个用于构建锁和同步容器的框架。

AQS使用一个FIFO的队列（也叫CLH队列，是[CLH锁](https://link.zhihu.com/?target=https%3A//blog.csdn.net/claram/article/details/83828768)(自旋锁)的一种变形），表示排队**等待锁的线程**。队列**头节点**称作“哨兵节点”或者“哑节点”，它不与任何线程关联。**其他的节点**与等待线程关联，每个节点维护一个等待状态waitStatus。结构如下图所示：

![image-20211107104309780](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202111071043874.png)



##### ReentrantLock的流程

1. ReentrantLock先通过CAS尝试获取锁，

2. 1. 如果此时锁已经被占用，该线程加入AQS队列并wait()

   2. 当前驱线程的锁被释放，挂在CLH队列为首的线程就会被notify()，然后继续CAS尝试获取锁，此时：

   3. 1. 非公平锁，如果有其他线程尝试lock()，有可能被其他刚好申请锁的线程**抢占**。
      2. 公平锁，只有在CLH**队列头的线程**才可以获取锁，**新来的线程**只能插入到队尾。

（注：ReentrantLock默认是非公平锁，也可以指定为公平锁）

ReentrantLock的2个构造函数：

```java
public ReentrantLock() {
    sync = new NonfairSync(); //默认，非公平
}
 
public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync(); //根据参数创建
}
```



##### 总结

0. 每一个ReentrantLock自身维护一个AQS队列记录申请锁的线程信息；

1. 通过大量CAS保证多个线程竞争锁的时候的并发安全；

2. 可重入的功能是通过维护state变量来记录重入次数实现的。

3. 公平锁需要维护队列，通过AQS队列的先后顺序获取锁，缺点是会造成大量线程上下文切换；

4. 非公平锁可以直接抢占，所以效率更高；



#### 15.ThreadLocal 实现原理是什么？

**作用:**

- ThreadLocal 用于在==多线程环境中安全的保存线程本地变量==，同一线程在某个地方保存数据，在随后的任意地方都可以获取到。
- 即使是同一个 threadLocal 变量，由于每个线程自己都有一个独立的 ThreadLocalMap，所以不同线程中保存的数据也是互不影响的。



**保存步骤:**

1. 每个线程（Thread 类对象）中都会有一个 ThreadLocalMap 类型的变量 threadLocals 来保存 ThreadLocal 中的数据。
2. 在保存数据的 threadLocal.set() 方法中，先通过 Thread.currentThread() 方法获取到当前线程
3. 通过 getMap(Thread t) 方法获取到当前线程的 ThreadLocalMap 对象
4. 以当前 threadLocal 对象为 key、需要保存的数据对象为 value，构造一个键值对 Entry 对象保存在 ThreadLocalMap 中
5. 调用 threadLocal.get() 方法取数据也是先获取到这个线程对象，然后以对应 threadLocal 对象为 key 从这个 ThreadLocalMap 中取出数据的。

注意，==一个 ThreadLocal 只能存储一个 Object 对象==，如果需要存储多个 Object 对象，那么就需要多个 ThreadLocal 来转化成多个 Entry 对象（键值对）进行存储。



 **数据结构**

1. 当使用 ThreadLocal 保存一个 value 时，会构造一个键值对 Entry 对象插入到 ThreadLocalMap 的数组中
2. Entry 继承自弱引用 **WeakReference 类**。构建 Entry 对象时，**key 是一个指向 ThreadLocal 对象的弱引用**，value 则为强引用。



**内存泄露问题:**

对于一个 ThreadLocal 对象，通常会有==两个引用==指向它：

- 一个是线程中声明的 threadLocal 变量，这是个强引用；
- 一个是线程底层 ThreadLocalMap 中键值对的 key，这是弱引用。
- 不再需要使用某 ThreadLocal 对象时，会采用将变量设置为 null（threadLocal = null）的方式释放掉线程中 threadLocal 变量与对象之间的引用关系，方便 GC 对 ThreadLocal 对象的回收。
- 但此时线程的 ThreadLocalMap 中还有 key 引用着这个 ThreadLocal 对象：如果这个引用是强引用，那么这个 **ThreadLocal 对象就可能永远不会被回收了，造成内存泄露**；但现在这里设计成弱引用，那么当垃圾收集器发现这个 ThreadLocal 对象只有**弱引用相关联时，就会回收它的内存**。
- 当前 Entry 对象的 key 设计成弱引用：Entry 对象中的 value 仍存在着内存泄露的隐患，**因为在垃圾回收 key 被清理掉的时候，强引用 value 中的对象并不会被清理掉**。
- ==最佳实践：应当在我们使用完 ThreadLocak 对象之后，主动调用 remove() 方法进行清理。==



**原理:**

![image-20211108100234908](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202111081002090.png)





**对比:**

![image-20211108100342811](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202111081003948.png)

JDK8设计方案的好处:

* 每个Map存储的Entry数量变少.
* 当Thread销毁的时候,ThreadLocalMap也会随之销毁,减少内存的使用.



#### 16.CAS 实现原理是什么？

CAS 被认为是一种乐观锁，有乐观锁，相对应的是悲观锁。

在上述示例中，我们使用了 ==synchronized，如果在线程竞争压力大的情况下，synchronized 内部会升级为重量级锁，此时仅能有一个线程进入代码块执行，如果这把锁始终不能释放，其他线程会一直阻塞等待下去。==此时，可以认为是悲观锁。

悲观锁会因线程一直阻塞导致系统上下文切换，系统的性能开销大。

那么，我们可以用乐观锁来解决，==所谓的乐观锁，其实就是一种思想==。

乐观锁，会以一种更加乐观的态度对待事情，认为自己可以操作成功。当多个线程操作同一个共享资源时，仅能有一个线程同一时间获得锁成功，在乐观锁中，其他线程发现自己无法成功获得锁，并不会像悲观锁那样阻塞线程，而是直接返回，可以去选择再次重试获得锁，也可以直接退出。



即 **compare and swap**（比较与交换）**，是一种有名的**无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blockingSynchronization）。**CAS** **算法**涉及到三个操作数

* 需要读写的内存值 V 
* 进行比较的值 A 
*  拟写入的新值 B

当且仅当 V 的值等于 A 时，CAS 通过原子方式用新值 B 来更新 V 的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个**自旋操**作**，即**不断的重试



由这段代码看到：

```java
unsafe.compareAndSwapInt(this, valueOffset, expect, update)
```

所谓的 CAS，其实是个简称，全称是 Compare And Swap，对比之后交换数据。上面的方法，有几个重要的参数：

（1）this，Unsafe 对象本身，需要通过这个类来获取 value 的内存偏移地址。

（2）valueOffset，value 变量的内存偏移地址。

（3）expect，期望更新的值。

（4）update，要更新的最新值。

如果原子变量中的 value 值等于 expect，则使用 update 值更新该值并返回 true，否则返回 false。



==CAS操作一般包含3个参数，期望值、内存值、新值。**如果期望值与内存值相等，则用新值去更新这个内存值。如果不相等，则可以再次进行比较，一直到成功为止**。==

```
/** 
    * @param expect 期望值 
    * @param update 新值 
    * @return 
    */ 
   public int cas(int expect, int update) { 
       //更新失败就一直进行忙循环 
       while (true) { 
           //get方法从内存中获取最新的值 
           int memory = get(); 
           if (memory == expect) { 
               //set方法将内存中的值设置为新值 
               set(update); 
               return update; 
           } 
       } 
   } 
```



#### 17.简述 Spring 的初始化流程

**spring容器的初始化过程如下图**

![img](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202111110956953.jpeg)



**Bean的初始化流程：**

![img](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202111110952341.jpeg)

> * Spring启动，查找并加载需要被Spring管理的bean，进行Bean的实例化 
> * Bean实例化后对将Bean的引入和值注入到Bean的属性中
> * 如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法
> * 如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入
> * 如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来。
> * 如果Bean实现了BeanPostProcessor接口，Spring就将调用他们的postProcessBeforeInitialization()方法。
> * 如果bean有被@PostConstruct注解的方法，会执行该方法；如果Bean 实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法。类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用
> * 如果Bean 实现了BeanPostProcessor接口，Spring就将调用他们的postProcessAfterInitialization()方法。
> * 此时，Bean已经准备就绪，可以被应用程序使用了。他们将一直驻留在应用上下文中，直到应用上下文被销毁。
> * 如果bean有被@PreDestroy注解的方法，执行该方法；如果bean实现了DisposableBean接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destory-method 声明销毁方法，该方法也会被调用。



#### 18.简述常见的工厂模式以及单例模式的使用场景

1.工厂模式

**创建型模式**

工厂模式分为三类:

- 简单工厂模式（Simple Factory）
- 工厂方法模式（Factory Method）
- 抽象工厂模式（Abstract Factory）

> 优点:
>
> * **可以使代码结构清晰，有效地封装变化**
> * **对调用者屏蔽具体的产品类**
> * **降低耦合度**产品类的实例化通常来说是很复杂的，它需要依赖很多的类，而这些类对于调用者来说根本无需知道，如果使用了工厂方法，我们需要做的仅仅是实例化好产品类，然后交给调用者使用。对调用者来说，产品所依赖的类都是透明的。
>
> 缺点:
>
> * 应用工厂方法模式需要引入许多新的子类， 代码可能会因此变得更复杂

使用场景:

- 我们最常用的 ==Spring 就是一个最大的 Bean 工厂==，IOC 通过`BeanFactory`对 Bean 进行管理。
- 我们使用的日志门面框架`slf4j`，点进去就可以看到熟悉的味道
- JDK 的 `Calendar` 使用了简单工厂模式





2.单例模式

==**确保某一个对象只有一个实例，而且自行实例化并向整个程序提供这个实例。**==

> 优点:
>
> * ==减少了内存开支==，特别是**一个对象需要频繁地创建、销毁**时，而且创建或销毁时性能又无法优化，单例模式的优势就非常明显
> * ==减少了系统的性能开销==，当**一个对象的产生需要比较多的资源**时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决。
> * ==避免对资源的多重占用==
> * 在系统设置全局的访问点，==优化和共享资源访问==
>
> 
>
> 缺点:
>
> * 单例模式一般没有接口，==扩展困难==。
> * 不利于测试

使用场景:

*  ==网站的计数器==

* ==应用程序的日志应用==，一般都何用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。

* Web应用的配置对象的读取，一般也应用单例模式，这个是由于配置文件是共享的资源。

* ==多线程的线程池==的设计一般也是采用单例模式，这是由于线程池要方便对池中的线程进行控制。

* ==数据库连接池==的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。

* HttpApplication 也是单例的典型应用。

  

应用场景:

* ==资源共享的情况下，避免由于资源操作时导致的性能或损耗等如上述中的日志文件==
* ==控制资源的情况下，方便资源之间的互相通信。如线程池等==。



#### 19.简述 Netty 线程模型，Netty 为什么如此高效？

Netty内核部分一览:

![v2-decb436aa27f8c9d4772323a75376e68_720w](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202111160847919.jpeg)

> - 内存管理
>   ==主要提高高效的内存管理==，包含内存分配，内存回收。
> - 网络通道
>   ==复制网络通信==，例如实现对NIO、OIO等底层JAVA API 的封装，简化网络编程模型。
> - 线程模型
>   提供==高效的线程协作==模型。



**Netty线程模型:**

主从多Reactor模型

![img](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202111160901618.jpeg)



* Acceptor
  请求接收者，在实践时其职责类似服务器，并不真正负责连接请求的建立，而只将其请求委托 Main Reactor 线程池来实现，==起到一个转发的作用==。
* Main Reactor
  ==主 Reactor 线程组，主要**负责连接事件**，并将**IO读写请求转发到 SubReactor 线程池**==。当然在一些需要对客户端进行权限控制等场景下，权限校验的职责可以放到 Main Reactor 线程池，即 **Main Reactor 也可以注册通道的读写事件**，读取客户端权限校验相关的数据包，执行权限验证，权限验证通过后再将2通道注册到IO线程。
* Sub Reactor
  Main Reactor 通常监听客户端连接后会将通道的读写==转发到 Sub Reactor 线程池中一个线程==(负载均衡)，负责数据的读写。在 NIO 中 通常注册通道的读(OP_READ)、写事件(OP_WRITE)。



**Netty的线程模型:**

Netty的线程模型是基于主从多Reactor模型。

![img](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202111160905839.jpeg)





**Netty 中 IO 线程的大体工作流程**

![img](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202111160907897.jpeg)

> IO线程处理的关键点：
>
> - 每一IO线程在执行上述操作时是串行执行的，即注册在一个 Selector(事件选择器)中的所有通道，**同一时间只有一个通道的事件被处理。**这也是为什么NIO应对大文件传输时不具备优势的根本原因。
> - IO 线程在处理完所有就绪事件后，还会从任务队列(Task Queue)获取任务，例如上文中提到的业务线程在执行完业务后需要将返回结果写入网络，**Netty 中所有的网络读写操作只能在IO线程中真正获得运行**，故业务线程需要将带写入的响应结果封装成 Task，放入到 IO 线程任务队列中。



**高性能的原因:**

> * ==非阻塞IO==
>
>   采用了IO多路复用技术，让多个IO的阻塞复用到一个select线程阻塞上，能够有效的应对大量的并发请求
>
> * ==高效的Reactor线程模型==
>
>   Netty服务端采用Reactor主从[多线程](https://so.csdn.net/so/search?from=pc_blog_highlight&q=多线程)模型
>
> * ==无锁化串行设计==
>
>   串行设计：消息的处理尽可能在一个线程内完成，期间不进行线程切换，避免了多线程竞争和同步锁的使用
>
> * ==高效的并发编程==
>
> * ==高性能序列化框架==
>
> * ==零拷贝==
>
> * ==内存池==
>
>   基于对象池的 ByteBuf可以重用 ByteBuf对象，内部维护了一个内存池，可以循环利用已创建ByteBuf，提升内存的使用效率，降低由于高负载导致的频繁GC



#### 20.线程池是如何实现的？简述线程池的任务策略

线程池由两部分组成:

* 阻塞队列
* 线程容器

根据阻塞队列是否是无界的java提供了两种不同的队列实现，一是==ArrayBlockingQueue==,另一是==LinkedBlockingQueue==。

> 线程容器类可以通过添加一个Set集合来存放活跃的线程，并包含一个阻塞队列的实例，当一个任务被添加时，可以通过判断工作线程的数量与核心线程数的大小，当不足时，可以开启一个新的线程去执行任务，若超出则将任务暂存在任务队列中。
>
> 任务队列的实现可以是一个简单的ArrayDeque 双端队列，其核心方法是对任务的取出与暂存操作，当需要取出一个任务时，必须进行非空判断，可以通过添加锁机制，例如Reetrantlock来实现锁空队列，当任务被暂存时，通过Condition条件唤醒需要取出任务的线程继续执行任务，从而实现类似生产者与消费者之间的平衡关系。
>
> 

#####  **Java中的线程池实现**

![img](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202111171028246.png)

ThreadPoolExecutor顶层接口为Executor，该接口提供了一个抽象方法 execute，提供一个Runnable类型的参数，ExecutorService是对execute的再次抽象，提供更多线程管理的抽象方法。

AbastractExecutorService 是上层的抽象类，对接口ExecutorService中的部分公用方法提供了一致的实现。ThreadPoolExecutor会一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。

![img](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202111171028717.jpeg)

线程池在内部实际上构建了一个消费者与生产者模型，将==线程==和==任务==执行两者解耦。

当任务提交后：

- 直接开启新线程处理任务
- 将任务暂存到队列中
- 拒绝策略



#####  **生命周期管理**

ThreadPoolExecutor 使用`ctl`高 3位来表示线程池状态，低29位表示线程数量。

![image-20211117102931704](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202111171029765.png)

| 状态名     | 高3位 | 接收新任务 | 处理阻塞队列任务 | 说明                                       |
| ---------- | ----- | ---------- | ---------------- | ------------------------------------------ |
| RUNNING    | 111   | 是         | 是               |                                            |
| SHUTDOWN   | 000   | 否         | 是               | 不会接收新任务，但会处理阻塞队列剩余 任务  |
| STOP       | 001   | 否         | 否               | 会中断正在执行的任务，并抛弃阻塞队列 任务  |
| TIDYING    |       | --         | --               | 任务全执行完毕，活动线程为 0 即将进入 终结 |
| TERMINATED |       | --         | --               | 终结状态                                   |

![img](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202111171029625.png)



#####  任务执行机制

![img](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202111171030402.png)

当任务提交后：

- 直接开启新线程处理任务
- 将任务暂存到队列中
- 拒绝策略



##### 任务暂存

> 阻塞队列(BlockingQueue)是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。

![img](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202111171030678.png)



##### 任务拒绝

> 任务拒绝模块是线程池的保护部分，线程池有一个最大的容量，当线程池的任务缓存队列已满，并且线程池中的线程数目达到maximumPoolSize时，就需要拒绝掉该任务，采取任务拒绝策略，保护线程池。

拒绝策略是一个接口，其设计如下：

```java
public interface RejectedExecutionHandler {
    void rejectedExecution(Runnable r, ThreadPoolExecutor executor);
}

```

用户可以通过实现这个接口去定制拒绝策略，也可以选择JDK提供的四种已有拒绝策略，其特点如下：

<img src="https://shuxie.oss-accelerate.aliyuncs.com/post/1/2021/40177v2-bcd9c1daf2263dbbe26c82c7aa67aa7f_720w.jpg" alt="img" style="zoom:150%;" />



#### 21.简述生产者消费者模型

##### 概念

生产者和消费者问题是线程模型中的经典问题：==生产者和消费者在同一时间段内共用同一个存储空间==，**生产者往存储空间中添加产品**，**消费者从存储空间中取走产品**，==当存储空间为空时，消费者阻塞，当存储空间满时，生产者阻塞。==

![img](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202111180847392.webp)

##### 为什么使用生产者和消费者模式？

在==线程世界==里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这个问题于是引入了生产者和消费者模式。



##### 使用java的5种实现方式

* wait（）和 notify()实现方式
* 可重入锁ReentrantLock的实现
* 阻塞队列实现(最简单)
* 信号量的实现
* 管道



#### 22.[?]简述 Spring 的 IOC 机制

ioc是一种思想

DI是ioc的实现方式



 IoC的英文叫做==Inversion of Control==,在面向对象的世界中，如果我们想在对象A中，操作对象B，那么A一定会持有B的引用（对象关系），而后才能进行操作。这样的带来的问题是***代码不够整洁、代码维护成本高、耦合度大***

*Spring IoC带来了这个问题的解决办法:*

> * Spring将==对象之间的依赖关系转而用配置文件来管理==，也就是Spring的DI——Dependency Injection（依赖注入），
> * 同时，==任何一个对象都应该有一个保存他的地方==，也就是IoC容器，IoC容器保存了所有的Bean对象，这个Bean对象就是真实的Object。
> * Spring通过IoC容器，进而操作这些Bean，从而达到==对这些对象管理以及一些列额外操作的目的==。



机制:

* 解析xml,获得对应的bean定义
* 实例化bean
* 根据注入方式进行注入
* 利用



#### 23.Java 如何高效进行数组拷贝

数组赋值方式,有以下4种:

* System.arraycopy()

==这是一个native方法==

```java
 public static native void arraycopy(Object src,  int  srcPos,
                                        Object dest, int destPos,
                                        int length);
```



* Arrays.copyOf()

==本质上调用的是System.arraycopy（）方法，也就是前一种方法，那么效率肯定比不上前一种数组复制方法==

```java
    public static <T,U> T[] copyOf(U[] original, int newLength, Class<? extends T[]> newType) {
        @SuppressWarnings("unchecked")
        T[] copy = ((Object)newType == (Object)Object[].class)
            ? (T[]) new Object[newLength]
            : (T[]) Array.newInstance(newType.getComponentType(), newLength);
        System.arraycopy(original, 0, copy, 0,
                         Math.min(original.length, newLength));
        return copy;
    }
```



* clone()

==这个方法是Object类中的一个本地方法，这里虽然返回Object，看着需要强制类型转换，但Object子类重写了这个方法，会返回相应的类型。==

```java
 protected native Object clone() throws CloneNotSupportedException;
```



* for循环

==循环原始数组并直接赋值到目标数组中。==



总结：

> （1）原始数组长度不管是多少的时候，==Arrays.copyOf（）的效率都比System.arraycopy（）差==。
>
> （2）原始数组长度比较小的时候，几百以内，for循环表现十分优异，并随着数组长度的增加，效率越来越低，因此，==for循环适合于小型数组==。
>
> （3）原始数组长度中等的时候，比如几千的时候，两个本地方法的效率差不多。
>
> （4）==原始数组长度比较大的时候，以万为单位，这时候本地方法System.arraycopy（）方法的优势体现出来了，力压其他三种方式。==



小数组:for循环

中数组:System.arraycopy()或者 Arrays.copyOf() 都行

大数组:System.arraycopy()



#### 24.成员变量和方法的区别？

**成员变量有两种:**

* 实例变量
* 类变量(静态变量,静态域)

**成员方法有三种**:

* 实例方法
* 类方法(静态方法)
* 构造器



#### 25.MVC 模型和 MVVM 模型的区别

区别：MVC中==Controller==演变成了MVVM中的==viewModel==。MVVM主要解决了MVC中大量的DOM操作带来的使页面渲染性能降低，加载速度变慢等问题。MVVM中当和Model频繁发生变化，开发者需要主动更新到View。



##### MVC

- M:model 模型层(模型层接受改变状态最终发送给视图层展现)
- V:view 视图层（传递用户交互的指令给控制层）
- C:controller 控制层（控制层实现相应的逻辑代码后返回给模型层）

![在这里插入图片描述](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202111190956982.png)

MVC模式的优缺点:

![image-20211119095844342](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202111190958406.png)



##### MVVM设计模式

MVVM是Model-View-ViewModel的简写。即模型-视图-视图模型。【模型】指的是后端传递的数据。【视图】指的是所看到的页面。【视图模型】mvvm模式的核心，它是连接view和model的桥梁。



- M:Model 模型层
- V:View 视图层
- VM:ViewModel 视图模型层



![在这里插入图片描述](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202111190959086.png)

==注意==:在MVVM模式中==,视图层和模型层不能直接联系==,==两者通过VM来进行关联==,当数据发生改变,VM进行监听,然后通知视图,反之,通知数据做改变。

MVVM模式的优点:
MVVM解决了MVC中大量的DOM操作使得==页面渲染性能降低==,==加载速度变慢==,==用户体验差==,以及当model层发生改变时,开发者需要主动更新页面的问题。





































































































---



### 其他

#### HashMap的长度为什么必须是2的次幂？

==为了实现一个尽量分布均匀的hash函数==，利用的是Key值的HashCode来做某种运算。因此问题来了，如何进行计算，才能让这个hash函数尽量分布均匀呢？首先想到的就是将Key值的HashCode值与HashMap的长度进行取模运算，即 index = HashCode(Key) % hashMap.length，但是，但是！这种取模方式运算固然简单，然而它的效率是很低的，浪费性能。所以jdk用了位运算的方式index = HashCode(Key) & (hashMap.length - 1);

> 举例：
> “abc”十进制hashcode为96354，二进制为‭1 0111 1000 0110 0010‬，HashMap的默认长度为16，与15进的二进制1111位运算， 得到index = 2；

==hash算法得到的index值完全取决与Key的HashCode的最后几位。这样做不但效果上等同于取模运算，而且大大提高了效率。==





#### 获取异常堆栈信息

```java
public static String getStackTrace(Throwable throwable)
{
    StringWriter sw = new StringWriter();
    PrintWriter pw = new PrintWriter(sw);

    try
    {
        throwable.printStackTrace(pw);
        return sw.toString();
    } finally
    {
        pw.close();
    }
}

// 使用
public static void test()
{
    try
    {
        int i = 0;
        int m = 10 / i;
    } catch (Exception e)
    {
        System.out.println(e.getMessage());
        System.out.println("------调皮的分割线------");
        System.out.println(ExceptionUtil.getStackTrace(e));
    }
}
```



### TOP k

#### 1.**简述 Java 的逃逸分析机制**

逃逸分为两种:

* 方法逃逸:

> **当一个对象在方法里面被定义之后,它可能会被外部方法所引用**,例如作为参数传递到其他方法,也即==对象逃离了方法的作用范围,这种行为被称为方法逃逸==

* 线程逃逸:

> 当==被定义的对象赋值给可以被其他线程所访问的对象时==,被称为线程逃逸



从不逃逸到方法逃逸直至线程逃逸的过程，称为对象由低到高的不同逃逸程度。

==不逃逸 ->方法逃逸->线程逃逸==



那么**为什么需要进行逃逸分析呢**，当一个对象分析之后确定不会出现逃离作用范围的问题，那么可以通过一些==手段==来优化这些对象而减少资源的消耗，例如：

> ==栈上分配==

​	Java在堆中分配创建对象的内存空间。Java堆中的对象是线程共享的，也就是说，只要持有某个对象的引用，就可以访问到堆中的对象。虚拟机的垃圾回收器会回收不再使用的对象，但无论是筛选出不再使用的对象还是回收和整理内存，都是非常耗费资源的。如果确定一个对象不会存在线程逃逸的问题，例如局部对象等所占的比例是非常大的，如果能使用栈上分配，那大量的对象就会随着方法的结束而自动销毁了，垃圾回收的压力也将大大减轻。

然而，这项优化仍在进行中。  



>  ==标量替换==

若一个数据已经无法再分解成更小的数据来表示，例如Java虚拟机中的原始数据类型都不能再进一步分解了，那么这些数据就可以称为**标量**。如果一个数据类型可以被进一步分解，例如对象，那它就被称为**聚合量**。

如果把一个对象拆散，根据程序访问的情况，将其用到的成员变量恢复到原始类型来访问，这个过程称为标量替换。

假如逃逸分析证明一个对象确实不会逃离方法的作用范围，并且这个对象可以被进一步分解，那么该==对象可能在程序执行时不会被创建，而创建若干个被该方法使用的成员变量来代替。==



> ==同步消除==

线程同步本身是一个相对耗时的过程，如果对一个变量进行逃逸分析确定不会逃出方法的作用范围，那么该变量一定不会出现线程安全问题，那么也就==不需要对这个变量实施同步措施==。

---



#### 2.**简述标记清除算法的流程**

标记清除算法(mark-sweep)==最早出现也是最基础的垃圾收集算法==,算法包含两个部分:标记和 清除

* 标记需要清除的对象
* 统一回收被标记的对象

**最基础:**后续的大多算法都是以标记清除算法为基础.不断的改进

**缺点:**

> * **执行效率不稳定**:如果java堆中包含==大量需要被回收的对象==，这时必须进行大量的标记清除动作，导致效率由于对象数量级的增长而降低。
> * **内存空间碎片化**:标记清楚之后会产生大量不连续的内存空间，当虚拟机需要分配较大的对象时而无法找到足够的连续内存空间，就不得不触发额外的垃圾回收动作。



![image-20211123091038081](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202111230910296.png)



#### 3.类加载与字节码技术

![img](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202111240833796.png)



##### 类文件结构

```java
// HelloWorld 示例
public class HelloWorld {
	public static void main(String[] args) {
		System.out.println("hello world");
	}
}
```

执行`javac -parameters -d . HellowWorld.java`

![image-20211124084305979](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202111240843183.png)

根据jvm规范，类文件结构如下

```
u4 magic;
u2 minor_version;
u2 major_version;
u2 constant_pool_count;
cp_info constant_pool[constant_pool_count-1];
u2 access_flags;
u2 this_class;
u2 super_class;
u2 interfaces_count;
u2 interfaces[interfaces_count];
u2 fields_count;
field_info fields[fields_count];
u2 methods_count;
method_info methods[methods_count];
u2 attributes_count;
attribute_info attributes[attributes_count];
```

##### 魔数

==0-3个字节,表示他是否是class类型文件==

0000000 ==ca fe ba be== 00 00 00 34 00 23 0a 00 06 00 15 09 



##### 版本

==4-7字节,表示类的版本00 34 (52) 表示java 8==

0000000 ca fe ba be $\textcolor{red}{00 00 00 34}$ 00 23 0a 00 06 00 15 09 



##### 常量池

==8~9 字节，表示常量池长度==，00 23 （35） 表示常量池有 #1~#34项，注意 #0 项不计入，也没有值 0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09 



##### 访问表示与继承信息

21 表示该 class 是一个类，公共的 

05 表示根据常量池中 #5 找到本类全限定名 

06 表示根据常量池中 #6 找到父类全限定名 





##### javap 工具

自己分析类文件结构太麻烦了，Oracle 提供了 javap 工具来反编译 class 文件 

```java
javap -v HelloWorld.class
```



##### 方法执行流程

* 原始java代码

> ```java
> package cn.itcast.jvm.t3.bytecode;
> /**
> * 演示 字节码指令 和 操作数栈、常量池的关系
> */
> public class Demo3_1 {
> 	public static void main(String[] args) {
> 		int a = 10;
> 		int b = Short.MAX_VALUE + 1;
> 		int c = a + b;
> 		System.out.println(c);
> 	}
> }
> ```

* 编译后的字节码文件

> ```java
> javap -v HelloWorld.class
> ```

* 常量池载入运行时常量池

![img](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202111240853794.png)



* 方法字节码载入方法区

![img](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202111240853972.png)

* main线程开始运行,分配栈帧内存

![img](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202111240854207.png)



* 执行引擎开始执行字节码

**bipush 10**

- **将一个 byte 压入操作数栈（其长度会补齐 4 个字节），类似的指令还有** 
- **sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节）** 
- **ldc 将一个 int 压入操作数栈** 
- **ldc2_w 将一个 long 压入操作数栈（分两次压入，因为 long 是 8 个字节）** 
- **这里小的数字都是和字节码指令存在一起，超过 short 范围的数字存入了常量池**

**........................**

![img](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202111240855868.png)





#### 4.**Java类加载过程**

三个步骤:

* 加载
* 链接
* 初始化

![123](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202111011120286.png)



##### 加载

==将类的字节码载入方法区中，内部采用 C++ 的 instanceKlass 描述 java 类==，它的重要 field 有：

- _java_mirror 即 java 的类镜像，例如对 String 来说，就是 String.class，作用是把 klass 暴 露给 java 使用
- _super 即父类
- _fields 即成员变量
- _methods 即方法
- _constants 即常量池
- _class_loader 即类加载器
- .....

> instanceKlass 这样的【元数据】是存储在方法区（1.8 后的元空间内），但 _java_mirror 是存储在堆中 可以通过前面介绍的 HSDB 工具

![img](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202111251015756.png)



##### 链接



###### **验证**

验证==类是否符合 JVM规范==，==安全性检查== 



###### 准备

- **为 static 变量分配空间**，设置默认值
- static 变量在 JDK 7 之前存储于 instanceKlass 末尾，从 JDK 7 开始，**存储于 _java_mirror 末尾**
- static 变量分配空间和赋值是两个步骤，**分配空间在准备阶段完成**，**赋值在初始化阶段完成 **
- **static 变量是 final 的，以及字符串常量，那么编译阶段值就确定了，赋值在准备阶段完成**
- 如果 static 变量是 final 的，但属于**引用类型，那么赋值也会在初始化阶段完成将常量池中的符号引用解析为直接引用**



###### 解析

将常量池中的==符号引用解析为直接引用== 



##### 初始化

发生的时机:

概括得说，类初始化是【懒惰的】 

- main 方法所在的类，总会被首先初始化
- 首次访问这个类的静态变量或静态方法时
- 子类初始化，如果父类还没初始化，会引发
- 子类访问父类的静态变量，只会触发父类的初始化
- Class.forName
- new 会导致初始化

不会导致类初始化的情况 

- 访问类的 static final 静态常量（基本类型和字符串）不会触发初始化
- 类对象.class 不会触发初始化
- 创建该类的数组不会触发初始化
- 类加载器的loadclass方法
- Class.forName的参数2为false时



##### 类加载器

| 名称                    | 加载哪的类            | 说明                          |
| ----------------------- | --------------------- | ----------------------------- |
| Bootstrap ClassLoader   | JAVA_HOME/jre/lib     | 无法直接访问                  |
| Extension ClassLoader   | JAVA_HOME/jre/lib/ext | 上级为 Bootstrap，显示为 null |
| Application ClassLoader | classpath             | 上级为 Extension              |
| 自定义类加载器          | 自定义                | 上级为 Applicatio             |



### Spring基础

#### Spring IOC & AOP

ioc理解

> * ==控制反转==:原来在程序中需要手动创建对象,现在需要什么对象直接由IOC容器提供,利于对象统一管理
> * ==依赖注入==:讲对象之间的相互依赖关系交给ioc容器管理,并由ioc容器完成对象得注入.简化开发,对象的创建

AOP

> AOP(Aspect-Oriented Programming,面向切面编程)：==能够将那些与业务无关，却为业务模块所用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来==，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。

**AOP应用场景:**

1. Authentication 权限
2. Caching 缓存
3. Context passing 内容传递
4. Error handling 错误处理
5. Lazy loading 懒加载
6. Debugging 调试
7. logging, tracing, profiling and monitoring 记录跟踪 优化 校准
8. Performance optimization 性能优化
9. Persistence 持久化
10. Resource pooling 资源池
11. Synchronization 同步
12. Transactions 事务



**AOP切面相关概念**

1. ==切面（aspect）==:类是对物体特征的抽象，切面就是对横切关注点的抽象
2. ==横切关注点：== 对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点。
3. ==连接点（joinPoint）==:被拦截到的点，因为 Spring 只支持方法类型的连接点，所以在 Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器。
4. ==切入点（pointcut）==:对连接点进行拦截的定义
5. ==通知（advice）==:所谓通知指的就是指拦截到连接点之后要执行的代码， 通知分为前置、后置、异常、最终、环绕通知五类。
6. ==目标对象：== 代理的目标对象
7. ==织入（weave）==:将切面应用到目标对象并导致代理对象创建的过程
8. ==引入（introduction）==:在不修改代码的前提下，引入可以在运行期为类动态地添加一些方法或字段





### Redis(<font  color='blue'>Remote Dictionary Server</font>)



#### 什么是Redis?

**Redis** 本质上是一个 `Key-Value` 类型的==内存数据库==





#### Redis**相比**memcached**有哪些优势？**

* `memcached`值是简单的字符串,`redis`支持丰富的数据类型
* `redis`速度比`memcached`块
* `redis`可以持久化数据



#### Redis**支持哪几种数据类型？**

* `String`
* `List`
* `Set`
* `Sorted Set`
* `hashes`



#### [?去中心化]Redis**集群方案应该怎么做？都有哪些方案？**

1.twemproxy，大概概念是，它类似于一个代理方式，使用方法和普通redis无任何区别，设置好它下属的多个redis实例后，使用时在本需要连接redis的地方改为连接twemproxy，它会以一个代理的身份接收请求并使用一致性hash算法，将请求转接到具体redis，将结果再返回twemproxy。使用方式简便(相对redis 只需修改连接端口)，对旧项目扩展的首选。

问题：twemproxy自身单端口实例的压力，使用一致性hash后，对redis节点数量改变时候的计算值的改变，数据无法自动移动到新的节点。



#### Redis**回收使用的是什么算法？**

==LRU算法==



#### **为什么要做**Redis**分区？**

==分区可以让Redis管理更大的内存==，Redis将可以使用所有机器的内存。如果没有分区，你最多只能使用一台机器的内存。分区使Redis的计算能力通过简单地增加计算机得到成倍提升,Redis的网络带宽也会随着计算机和网卡的增加而成倍增长



#### **如何实现集群中的**session**共享存储？**

<font  color='cblue'>什么是Session? 服务器为了保存用户状态而创建的一个特殊的对象</font>

Session是运行在一台服务器上的，所有的访问都会到达我们的唯一服务器上，这样我们可以根据客户端传来的sessionID，来获取session，或在对应Session 不存在的情况下（session生命周期到了/用户第一次登录），创建一个新的Session；但是，如果我们在集群环境下，假设我们有两台服务器A，B，用户的请求会由Nginx服务器进行转发（别的方案也是同理），用户登录时，Nginx 将请求转发至服务器A上，A创建了新的session，并将SessionID返回给客户端，用户在浏览其他页面时，客户端验证登录状态，Nginx将请求转发至服务器B，由于B上并没有对应客户端发来sessionId的session，所以会重新创建一个新的session，并且再将这个新的sessionID返回给客户端，这样，我们可以想象一下，用户每一次操作都有1/2的概率进行再次的登录，这样不仅对用户体验特别差，还会让服务器上的session激增，加大服务器的运行压力。

![image-20211127143255223](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202111271432308.png)



#### **Redis** **有哪几种数据淘汰(回收)策略？** 

`noeviction`:==不淘汰任何键值对==，当内存满时，如果进行读操作，例如get命令，它将正常工作，而做写操作，它将返回错误，也就是说，<font  color='red'>**当Redis采用这个策略内存达到最大的时候**，它就只能读不能写了。</font>



`allkeys-lru`: ==尝试回收最少使用的键（LRU）==，使得新添加的数据有空间存放。

`volatile-lru`: ==尝试回收最少使用的键（LRU）==，<font  color='cblue'>但仅限于在过期集合的键</font>,使得新添加的数据有空间存放。



`allkeys-random`: ==回收随机的键==使得新添加的数据有空间存放。

`volatile-random`: ==回收随机的键==使得新添加的数据有空间存放，<font  color='blue'>但仅限于在过期集合的键。</font>



`volatile-ttl`: ==回收在过期集合的键==，<font  color='orange'>并且优先回收存活时间（TTL）较短的键</font>,使得新添加的数据有空间存放。



> 总结
>
> :palm_tree:大类上有四种淘汰策略,小类上有六种
>
> * 不淘汰任何键值对
> * 尝试回收最少使用的键
>   * 无额外要求
>   * 限于过期集合中的键
> * 回收随机的键
>   * 无额外要求
>   * 限于过期集合中的键
> * 回收过期集合中的键



#### 一个字符串类型的值能存储最大容量是多少？

`512M`



#### 为什么 Redis 需要把所有数据放到内存中？

==Redis 为了达到最快的读写速度将数据都读到内存中==，<font  color='cblue'>并通过异步的方式将数据写入磁盘 </font>。所以 redis 具有`快速`和`数据持久化`的特征。<font  color='red'>如果不将数据放在内存中，磁盘 I/O 速度为严重影响 redis 的性能</font>。在内存越来越便宜的今天，redis 将会越来越受欢迎。 如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。





#### Redis 集群方案什么情况下会导致整个集群不可用？

有 A，B，C 三个节点的集群,在没有复制模型的情况下,如果节点 B 失败了，那么整个集群就会以为缺少 5501-11000 这个`范围的槽`而不可用。



#### MySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证 redis 中的数据都是热点数据？

redis 内存数据集大小上升到一定大小的时候，就会施行`数据淘汰策略`



#### Redis 有哪些适合的场景？

> :candy:会话缓存
>
> 最常用的一种使用 Redis 的情景是`会话缓存`（session cache）。用 Redis 缓存会话比其他存储（如 Memcached）的优势在于：<font  color='red'>Redis 提供持久化</font>。
>
>  
>
> :candy:全页缓存（FPC）
>
> 除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。回到一致性问题，即使重启了Redis 实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似 PHP 本地 FPC。
>
>  
>
> :candy:队列
>
> Reids 在内存存储引擎领域的一大优点是提供 `list `和` set` 操作，<font  color='cblue'>这使得 Redis 能作为一个很好的消息队列平台来使用</font>
>
>  
>
> :candy:排行榜/计数器
>
> Redis 在内存中对数字进行`递增`或`递减`的<font  color='blue'>操作实现的非常好</font>。`集合`（Set）和`有序集合`（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，<font  color='orange'>Redis 只是正好提供了这两种数据结构</font>
>
>  
>
> :candy:发布/订阅
>
> 发布/订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器



#### Redis 支持的 Java 客户端都有哪些？官方推荐用哪个？

`Redisson`、`Jedis`、`lettuce` 等等，官方推荐使用` Redisson`。



#### Redis 和 Redisson 有什么关系？

Redisson 是一个`高级的分布式协调 Redis 客服端`



#### 说说 Redis 哈希槽的概念？

Redis 集群<font  color='red'>没有使用一致性 hash</font>,而是引入了`哈希槽`的概念，Redis 集群有 ==16384== 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，<font  color='cblue'>集群的每个节点负责一部分hash 槽</font>



#### Redis 集群的主从复制模型是怎样的？

<font  color='blue'>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用</font>，所以集群使用了主从复制模型,每个节点都会有` N-1 `个==复制品==



#### Redis 集群会有写操作丢失吗？为什么

==Redis 并不能保证数据的强一致性==，这意味这在实际中集群在特定的条件下<font  color='cblue'>可能会丢失写操作</font>。





























































































































































































































---





### MyBatis & MyBatis-Plus

#### 1. #{}和${}的区别是什么？ 

* `#{}` 预编译<font color='purple'>处</font>理,<font  color='orange'>可以防止sql注入</font>
* `${}`字符串替换

>  Mybatis 在处理#{}时，==会将 sql 中的#{}替换为?号==，调用 PreparedStatement 的 set 方法来赋值； 
>
>  Mybatis 在处理\${}时，就是==把${}替换成变量的值==。 
>
>  ==使用#{}可以有效的防止 SQL 注入，提高系统安全性==。



#### 2.通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应， 请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？

> <font color='red'>Dao 接口，就是人们常说的 Mapper 接口，接口的全限名，就是映射文件中的 namespace 的值</font>，
>
> <font color='orange'>接口的方法名，就是映射文件中 MappedStatement 的 id 值</font>，
>
> <font color='green'>接口方法内的参数， 就是传递给 sql 的参数。</font>
>
> ==Mapper 接口是没有实现类的==，
>
> 当调用接口方法时，<font color='cornflowerblue'>接口全限名+ 方法名拼接字符串作为 key 值，可唯一定位一个 MappedStatement，</font>
>
> 在 Mybatis 中，每一个`<select>`、`<insert>`、`<update>`、`<delete>` 标签，<font color='red'>都会被解析为一个 MappedStatement 对象</font>

> ==Dao 接口里的方法，是不能重载的==，因为是全限名+方法名的保存和寻找策略。

> Dao 接口的工作原理是 <font color='red'>JDK 动态代理</font>，Mybatis <font color='orange'>**运行时会使用 JDK 动态代理为 Dao 接 口 生 成 代 理 proxy 对 象** </font>， 代 理 对 象 proxy 会 拦 截 接 口 方 法 ，<font color='orange'> **转 而 执 行 MappedStatement 所代表的 sql，然后将 sql 执行结果返回。** </font>



#### 3. Mybatis 是如何进行分页的？分页插件的原理是什么？

> Mybatis 使用 <font color='red'>RowBounds</font> 对象进行分页，它是==针对 ResultSet 结果集执行的内存分页， 而非物理分页==，可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能
>
> 也可以使 用==分页插件来完成物理分页==。

> 分页插件的基本原理是使用 Mybatis 提供的插件接口，实现自定义插件，<font color='orange'>在插件的 拦截方法内拦截待执行的 sql，然后重写 sql</font>，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。





#### 4.Mybatis 是如何将 sql 执行结果封装为目标对象并返回的？ 都有哪些映射形式？

> <font  color='red'>第一种是</font><font  color='red'>使用</font>`<resultMap>`<font  color='red'>标签</font>，逐一定义列名和对象属性名之间的映射关系。
>
> 
>
> <font  color='red'>第二 种是</font><font  color='red'>使用 sql 列的别名功能</font>，将列别名书写为对象属性名，比如 T_NAME AS NAME，对象属性名一般是 name，小写，但是列名区分大小写，Mybatis 会忽略列名大小 写，智能找到与之对应对象属性名，你甚至可以写成 T_NAME AS NaMe，Mybatis 一样可以正常工作。 
>
> 有了列名与属性名的映射关系后，==Mybatis 通过反射创建对象，同时使用反射给对象 的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的==





#### 5. Xml 映射文件中，除了常见的 select|insert|update|delete 标 签之外，还有哪些标签？

> 还 有 很 多 其 他 的 标 签 ， 加 上 动 态 sql 的 9 个 标 签 ， 
>
> `trim`|`where`|`set`|`foreach`|`if`|`choose`|`when`|`otherwise`|`bind `等 ， 
>
> 其 中 为 sql 片 段标签，通过标签引入 sql 片段，为不支持自增的主键生成策略标签。



#### 6.简述 Mybatis 的插件运行原理，以及如何编写一个插件

> Mybatis 仅 可 以 编 写 针 对 `ParameterHandler` 、 `ResultSetHandler` 、 `StatementHandler`、`Executo`r 这 4 种接口的插件，
>
> Mybatis 使用 ==JDK 的动态代理==， <font  color='red'>为需要拦截的接口生成代理对象以实现接口方法拦截功能</font>，每当执行这 4 种接口对象 的方法时，就会进入拦截方法，具体就是 InvocationHandler 的 invoke()方法，当 然，只会拦截那些你指定需要拦截的方法。实现 Mybatis 的 Interceptor 接口并复写 intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可， 记住，<font  color='red'>还需要在配置文件中配置你编写的插件</font>



#### 7.一级、二级缓存



> * ==一级缓存==: <font  color='orange'>基于 PerpetualCache 的 HashMap 本地缓存</font>，其存储作用域为<font  color='orange'> Session</font>，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将 清空
> * ==二级缓存==与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存 储，<font  color='orange'>不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源</font>，如 Ehcache。要开启二级缓存，你需要在你的 SQL 映射文件中添加一行：`<cache/>`,<font  color='orange'>使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态)</font>
> *  ==缓 存 数 据 更 新 机 制== ， 当 某 一 个 作 用 域 ( 一 级 缓 存 Session/ 二 级 缓 存 Namespaces)的进行了 C/U/D 操作后(除了读取的操作)，<font  color='orange'>默认该作用域下所有 select 中的缓存将 被 clear</font>。



#### 8.Mybatis 是否支持延迟加载？如果支持，它的实现原理是什 么？

> Mybatis 仅支持 `association` 关联对象和 `collection `关联集合对象的延迟加载，
>
> * <font  color='green'>association</font> 指的就是一对一，
>
> * <font  color='green'>collection</font> 指的就是一对多查询。
>
>   在 Mybatis 配置文 件中，可以配置是否启用延迟加载` lazyLoadingEnabled=true|false`。 
>
> 
>
> 它的原理是，==使用 CGLIB 创建目标对象的代理对象==，当调用目标方法时，进入拦截 器方法，比如调用 a.getB().getName()，拦截器 invoke()方法发现 a.getB()是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调 用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 a.getB().getName()方法的 调用。这就是延迟加载的基本原理。



#### 9.Mybatis 映射文件中，如果 A 标签通过 include 引用了 B 标 签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在 A 标签的前面？

> 虽然 Mybatis 解析 Xml 映射文件是按照顺序解析的，但是，<font  color='cornflowerblue'>被引用的 B 标签依然可以定义在任何地方</font>，Mybatis 都可以正确识别。 
>
> 原理是，Mybatis 解析 A 标签，发现 A 标签引用了 B 标签，但是 B 标签尚未解析到， 尚不存在，此时，Mybatis 会将 A 标签标记为<font  color='cornflowerblue'>未解析状态</font>，然后继续解析余下的标签， 包含 B 标签，待所有标签解析完毕，Mybatis 会重新解析那些被标记为未解析的标 签，此时再解析 A 标签时，B 标签已经存在，A 标签也就可以正常解析完成了。
>



#### 10.简述 Mybatis 的 Xml 映射文件和 Mybatis 内部数据结构之 间的映射关系？

> Mybatis 将所有 Xml 配置信息都封装到 All-In-One 重量级对象==Configuration== 内 
>
> 部。在 Xml 映射文件中，`<parameterMap>`标签会被解析为 ==ParameterMap== 对象， 
>
> 其每个子元素会被解析为 ==ParameterMapping==对象。`<resultMap>`标签会被解析为 
>
> ==ResultMap==对象，其每个子元素会被解析为 ==ResultMapping== 对象。每一个`<select>`、 
>
> `<insert>`、`<update>`、`<delete>`标签均会被解析为 ==MappedStatement== 对象，标签 
>
> 内的 `sql` 会被解析为 ==BoundSql== 对象。
>
> 
>
> * `XMl`								   -> ==Configuration==
>
> * `<parameterMap>`	        -> ==ParameterMap==
>
> * `<parameterMap>子元素`  -> ==ParameterMapping==
>
> * `<resultMap>`                  -> ==ResultMap==
>
> * `<resultMap>子元素`        -> ==ResultMapping==  
>
> * `<select>`
>
>   `<insert>`
>
>   `<update>`
>
>   `<delete>`                         ->==MappedStatement==



#### 11.什么是MyBatis

> MyBatis是一个可以自定义 <font  color='orange'>SQL</font>、<font  color='orange'>存储过程</font>和<font  color='orange'>高级映射</font>的==持久层框架==



#### 12.Mybatis 动态 sql 是做什么的？都有哪些动态 sql？能简述一下动态 sql 的执行原理不？

> 动态 sql 可以让我们在 Xml 映射文件内，<font  color='red'>以标签的形式编写动态 sql</font>，==完成逻辑判断和动态拼接 sql== 的功能
>
> 
>
> Mybatis 提供了 9 种动态 sql 标签：
>
> `trim`|`where`|`set`|`foreach`|`if`|`choose`|`when`|`otherwise`|`bind `
>
> 
>
> 其执行原理为，使用 <font  color='red'>OGNL 从 sql 参数对象中计算表达式的值</font>，==根据表达式的值动态拼接 sql==，以此来完成动态 sql 的功能。
>
> **补充:**
>
> **MyBatis常用OGNL表达式**
>
> ![image-20211201081647092](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202112010816320.png)
>
>  **MyBatis中什么地方可以使用OGNL？**
>
> - 动态SQL表达式中
>
> ![image-20211201082129874](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202112010821098.png)
>
> - ${param}参数中
>
> ![image-20211201082325990](https://gitee.com/ICDM_ws/pic-bed/raw/master/all/202112010823207.png)



#### 13.为什么说 Mybatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？

> <font  color='red'>Hibernate 属于全自动 ORM 映射工具</font>，使用 Hibernate 查询关联对象或者关联集合对象时，<font  color='red'>可以根据对象关系模型直接获取，所以它是全自动的</font>。而 Mybatis 在查询关联对象或关联集合对象时，<font  color='orange'>需要手动编写 sql 来完成，所以，称之为半自动 ORM 映射工具</font>。



#### 14.MyBatis 与 Hibernate 有哪些不同？

> 1. Mybatis ==它不完全是一个 ORM 框架，因为 MyBatis 需要程序员自己编写 Sql 语句==，不过<font  color='cornflowerblue'> mybatis 可以通过 XML 或注解方式灵活配置要运行的 sql 语句</font>，并将java 对象和 sql 语句映射生成最终执行的 sql，最后将 sql 执行的结果再映射生成 java 对象
> 2. Mybatis 学习门槛低，简单易学，==程序员直接编写原生态 sql，可严格控制 sql 执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发==，例如互联网软件、企业运营类软件等，因为这类软件需求化频繁，一但需求变化要求成果输出迅速。<font  color='cornflowerblue'>但是灵活的前提是 mybatis 无法做到数据库无关性，如果需实现支持多种数据库的软件则需要自定义多套 sql 映射文件，工作量大</font>
> 3. ==Hibernate 对象/关系映射能力强，数据库无关性好，==对于关系模型要求高的软件（例如需求固定的定制化软件）如果用 hibernate 开发可以节省很多代码，提高效率。<font  color='cornflowerblue'>但是Hibernate 的缺点是学习门槛高，要精通门槛更高，而且怎么设计 O/R 映射，在性能和对象模型之间如何权衡，以及怎样用好 Hibernate 需要具有很强的经验和能力才行</font>
>
> `MyBatis`:
>
> * 半自动ORM框架
> * 直接编写原生态SQL,灵活度高
> * 数据库相关性强
> * 易学
>
> `Hibernate`:
>
> * 全自动ORM框架
> * 对象\关系映射能力强
> * 数据库无关
> * 难学



#### 15.MyBatis 的好处是什么？

> * ==MyBatis 把 sql 语句从 Java 源程序中独立出来，放在单独的 XML 文件中编写==，给程序的维护带来了很大便利
> * MyBatis 封装了底层 JDBC API 的调用细节，==并能自动将结果集转换成 Java Bean 对象，大大简化了 Java 数据库编程的重复工作。==
> * 因为 MyBatis 需要程序员==自己去编写 sql 语句==，程序员可以结合数据库自身的特点灵活控制 sql 语句，因此能够实现比 Hibernate 等全自动 orm 框架==更高的查询效率，能够完成复杂查询==



#### 16.什么是 MyBatis 的接口绑定,有什么好处？

> 接口映射就是在MyBatis中任意定义接口,然后==把接口里面的方法和SQL语句绑定,我们直接调用接口方法==就可以,这样<font  color='red'>比起原来的SqlSession提供的方法我们可以有更加灵活的选择和设置</font>.



#### 17.接口绑定有几种实现方式,分别是怎么实现的?

> * 接口绑定有两种实现方式,一种是==通过注解绑定==,就是在接口的方法上面加上`@Select` `@Update` 等注解里面包含 Sql 语句来绑定,
>
> * 另外一种就是==通过 xml 里面写 SQL 来绑定==,在这种情况下,要指定 <font  color='orange'>xml 映射文件里面的</font><font  color='orange'> namespace 必须为接口的全路径名</font>



#### 18.什么情况下用注解绑定,什么情况下用 xml 绑定？

> <font  color='red'>当 Sql 语句比较简单时候,用注解绑定</font>；
>
> <font  color='cornflowerblue'> SQL 语句比较复杂时候,用 xml 绑定</font>,
>
> 一般用xml 绑定的比较多



#### 19.MyBatis 实现一对一有几种方式?具体怎么操作的？

> 有==联合查询==和==嵌套查询==,
>
> 联合查询是几个表联合查询,只查询一次,通过在 resultMap 里面配置 association 节点配置一对一的类就可以完成;
>
> 嵌套查询是先查一个表,根据这个表里面的结果的外键 id,去再另外一个表里面查询数据,也是通过 association 配置,但另外一个表的查询通过 select 属性配置



#### 20.Mybatis 能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？

> 能，Mybatis 不仅可以执行`一对一`、`一对多`的关联查询，还可以执行`多对一`，`多对多`的关联查询，多对一查询，其实就是一对一查询，只需要把 `selectOne()`修改为 `selectList()`即可；多对多查询，其实就是一对多查询，只需要把 `selectOne()`修改为 `selectList()`即可。
>
> 关联对象查询，有两种实现方式，一种是单独发送一个 sql 去查询关联对象，赋给主对象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用 join 查询，一部分列是 A 对象的属性值，另外一部分列是关联对象 B 的属性值，==好处是只发一个 sql 查询，就可以把主对象和其关联对象查出来==。



#### 21.MyBatis 里面的动态 Sql 是怎么设定的?用什么语法?

> MyBatis 里面的动态 Sql 一般是通过` if `节点来实现,通过 `OGNL `语法来实现,但是如果要写的完整,必须配合 `where`,`trim` 节点,`where `节点是判断包含节点有内容就插入 `where`,否则不插入,`trim` 节点是用来判断如果动态语句是以 `and` 或` or` 开始,那么会自动把这个 `and` 或者 `or`取掉。



#### 22.Mybatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？

> 第一种是使用`<resultMap>`标签，逐一定义<font  color='red'>列名</font>和<font  color='orange'>对象属性名</font>之间的映射关系。
>
> 第二种是使用 ==sql 列的别名功能==，将列别名书写为对象属性名，比如 T_NAME AS NAME，对象属性名一般是 name，小写，但是<font  color='cornflowerblue'>列名不区分大小写，Mybatis 会忽略列名大小写</font>，智能找到与之对应对象属性名，你甚至可以写成 T_NAME AS NaMe，Mybatis 一样可以正常工作。
>
> <font  color='cornflowerblue'>有了列名与属性名的映射关系后，Mybatis 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</font>





































































































---

